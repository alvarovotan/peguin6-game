<!DOCTYPE html>
<html lang="pt-PT">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Peguin 6 - Multiplayer Online</title>
    <style>
        :root {
            --bg-color: #121212;
            --surface-color: #1e1e1e;
            --sidebar-color: #181818;
            
            --text-primary: #e0e0e0;
            --text-secondary: #a0a0a0;
            
            --accent-color: #bb86fc;
            --danger-color: #cf6679;
            --warning-color: #e67e22;
            
            /* Cores dos TdB */
            --tdb-low: #7f8c8d;
            --tdb-med: #f1c40f;
            --tdb-high: #e74c3c;

            /* Tamanhos Padr√£o (Desktop) */
            --card-w: 48px;
            --card-h: 74px;
            --row-gap: 8px;
            --row-h: 94px;
            --row-padding: 8px;
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-primary);
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        /* --- Lobby Screen --- */
        #lobby-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100vh;
            gap: 30px;
        }

        .lobby-container {
            background: var(--surface-color);
            padding: 40px;
            border-radius: 16px;
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            max-width: 500px;
            width: 90%;
        }

        .lobby-title {
            text-align: center;
            font-size: 2rem;
            font-weight: 300;
            letter-spacing: 3px;
            margin-bottom: 10px;
            color: var(--text-primary);
        }

        .lobby-subtitle {
            text-align: center;
            font-size: 0.9rem;
            color: var(--accent-color);
            margin-bottom: 30px;
            opacity: 0.8;
        }

        .input-group {
            margin-bottom: 20px;
        }

        .input-group label {
            display: block;
            margin-bottom: 8px;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .input-group input {
            width: 100%;
            padding: 12px 15px;
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 1rem;
            transition: all 0.3s;
        }

        .input-group input:focus {
            outline: none;
            border-color: var(--accent-color);
            background: rgba(0,0,0,0.4);
        }

        .btn-group {
            display: flex;
            gap: 10px;
            margin-top: 25px;
        }

        .btn {
            flex: 1;
            padding: 12px 20px;
            background: transparent;
            border: 1px solid var(--text-primary);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn:hover {
            background: var(--text-primary);
            color: var(--bg-color);
        }

        .btn-primary {
            border-color: var(--accent-color);
            color: var(--accent-color);
        }

        .btn-primary:hover {
            background: var(--accent-color);
            color: var(--bg-color);
        }

        .room-info {
            margin-top: 20px;
            padding: 15px;
            background: rgba(187, 134, 252, 0.1);
            border: 1px solid var(--accent-color);
            border-radius: 8px;
            display: none;
        }

        .room-info.show {
            display: block;
        }

        .room-code {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--accent-color);
            text-align: center;
            margin: 10px 0;
            letter-spacing: 3px;
        }

        .room-link {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .room-link input {
            flex: 1;
            padding: 8px 12px;
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 0.85rem;
        }

        .room-link button {
            padding: 8px 15px;
            background: var(--accent-color);
            border: none;
            border-radius: 6px;
            color: var(--bg-color);
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 600;
        }

        .players-list {
            margin-top: 20px;
            padding: 15px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            min-height: 100px;
        }

        .player-item {
            padding: 8px;
            margin-bottom: 5px;
            background: rgba(255,255,255,0.05);
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .player-item.host::after {
            content: "üëë";
            margin-left: 8px;
        }

        .error-message {
            margin-top: 15px;
            padding: 10px;
            background: rgba(207, 102, 121, 0.2);
            border: 1px solid var(--danger-color);
            border-radius: 6px;
            color: var(--danger-color);
            font-size: 0.85rem;
            display: none;
        }

        .error-message.show {
            display: block;
        }

        /* --- Game Screen (hidden by default) --- */
        #game-screen {
            display: none;
            width: 100%;
            height: 100vh;
            flex-direction: column;
            align-items: center;
        }

        #game-screen.show {
            display: flex;
        }

        /* --- Responsividade Tablet --- */
        @media (max-width: 900px) {
            :root {
                --card-w: 42px;
                --card-h: 64px;
                --row-gap: 5px;
                --row-h: 80px;
                --row-padding: 6px;
            }
            
            .main-layout {
                flex-direction: column;
                height: auto;
                min-height: calc(100vh - 60px);
            }
            
            .sidebar {
                width: 100%;
                height: auto;
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: center;
                gap: 15px;
                padding: 10px;
            }
            
            .scoreboard-title {
                width: 100%;
                text-align: center;
            }
            
            .score-entry {
                min-width: 120px;
            }
        }
        
        /* --- Responsividade Mobile --- */
        @media (max-width: 768px) {
            :root {
                --card-w: 42px;
                --card-h: 62px;
                --row-gap: 4px;
                --row-h: 72px;
                --row-padding: 5px;
            }
            
            body {
                overflow: hidden;
                height: 100vh;
                min-height: 100vh;
            }
            
            /* === LOBBY - Tela inicial limpa === */
            .lobby-container {
                padding: 20px;
                width: 95%;
            }
            
            .lobby-title {
                font-size: 1.4rem;
            }
            
            .lobby-subtitle {
                font-size: 0.8rem;
            }
            
            .btn-group {
                flex-direction: column;
            }
            
            .btn {
                width: 100%;
            }
            
            /* === GAME SCREEN - Layout otimizado === */
            #game-screen {
                height: 100vh;
                min-height: 100vh;
                padding-bottom: 0;
                display: none;
                flex-direction: column;
                overflow: hidden;
            }
            
            #game-screen.show {
                display: flex;
            }
            
            .main-layout {
                flex-direction: column;
                height: calc(100vh - 50px);
                width: 100%;
                padding: 0 5px;
                gap: 2px;
                overflow: hidden;
                padding-bottom: 0;
            }
            
            .game-area {
                width: 100%;
                order: 1;
                flex: 1;
                display: flex;
                flex-direction: column;
                overflow: hidden;
                padding-bottom: 95px;
            }
            
            /* Ocultar sidebar no mobile */
            .sidebar {
                display: none !important;
            }
            
            /* Ocultar placar inline antigo no mobile */
            .mobile-inline-placar {
                display: none !important;
            }
            
            /* Ocultar bot√£o flutuante antigo */
            .mobile-placar-btn {
                display: none !important;
            }
            
            /* Bot√£o de placar no header - apenas mobile */
            .mobile-placar-header-btn {
                display: block !important;
                background: rgba(187, 134, 252, 0.15);
                border: 1px solid var(--accent-color);
                color: var(--accent-color);
                padding: 5px 12px;
                border-radius: 20px;
                font-size: 0.7rem;
                font-weight: bold;
                text-transform: uppercase;
                cursor: pointer;
                transition: all 0.2s;
            }
            
            .mobile-placar-header-btn:hover {
                background: var(--accent-color);
                color: var(--bg-color);
            }
            
            /* Modal do placar retr√°til */
            .mobile-placar-modal {
                position: fixed !important;
                top: 50px !important;
                left: 10px !important;
                right: 10px !important;
                background: var(--surface-color) !important;
                border: 1px solid var(--accent-color) !important;
                border-radius: 12px !important;
                z-index: 1001 !important;
                padding: 15px !important;
                box-shadow: 0 10px 30px rgba(0,0,0,0.8) !important;
                max-height: 60vh !important;
                overflow-y: auto !important;
                display: none;
            }
            
            .mobile-placar-modal.show {
                display: block !important;
            }
            
            .scoreboard-title {
                width: 100%;
                font-size: 0.9rem;
            }
            
            .score-entry {
                min-width: 100px;
                padding: 8px;
                font-size: 0.8rem;
            }
            
            .score-name {
                max-width: 80px;
            }
            
            /* === BOARD - Cartas da mesa === */
            .board {
                padding: 4px 8px;
                width: 100%;
                overflow-x: auto;
                overflow-y: visible;
                max-height: none;
                flex: 1;
                display: flex;
                flex-direction: column;
                justify-content: flex-start;
                align-items: center;
            }
            
            .row {
                width: calc((6 * var(--card-w)) + (5 * var(--row-gap)) + (2 * var(--row-padding)));
                min-width: fit-content;
                max-width: 100%;
                height: var(--row-h);
            }
            
            .row-wrapper {
                gap: 8px;
                margin-bottom: 3px;
            }
            
            .radio-label {
                width: 24px;
                height: 24px;
                border-width: 2px;
            }
            
            #status-bar {
                font-size: 0.75rem;
                padding: 4px 8px;
                min-height: 26px;
            }
            
            header {
                padding: 6px 10px !important;
            }
            
            header h1 {
                font-size: 1rem;
            }
            
            .subtitle {
                font-size: 0.6rem;
            }
            
            .card {
                width: var(--card-w);
                height: var(--card-h);
            }
            
            .card-number {
                font-size: 1.1rem;
            }
            
            .card-dots {
                font-size: 4px;
                line-height: 4px;
            }
            
            /* === PLAYER AREA - Footer fixo e compacto === */
            .player-area {
                position: fixed !important;
                bottom: 0 !important;
                left: 0 !important;
                right: 0 !important;
                width: 100% !important;
                max-width: 100% !important;
                margin: 0 !important;
                padding: 6px 5px 8px 5px !important;
                background-color: var(--surface-color) !important;
                border-radius: 12px 12px 0 0 !important;
                box-shadow: 0 -4px 20px rgba(0,0,0,0.6) !important;
                z-index: 100 !important;
                border: 1px solid rgba(255,255,255,0.1) !important;
                border-bottom: none !important;
            }
            
            .player-area > div:first-child {
                margin-bottom: 4px !important;
                color: var(--text-secondary) !important;
                font-size: 0.6rem !important;
                text-align: center !important;
                font-weight: 600 !important;
                letter-spacing: 1px !important;
                text-transform: uppercase !important;
            }
            
            .hand {
                gap: 3px;
                flex-wrap: wrap;
                justify-content: center;
                padding: 0 2px;
            }
            
            /* Cartas da m√£o menores para caber todas */
            .hand .card {
                cursor: pointer;
                width: 30px !important;
                height: 44px !important;
            }
            
            .hand .card .card-number {
                font-size: 0.85rem;
            }
            
            .hand .card .card-dots {
                font-size: 3px;
                line-height: 3px;
            }
            
            .bots-action-area {
                min-height: 16px;
                margin-bottom: 2px;
            }
            
            .bot-action-card {
                font-size: 0.65rem;
                padding: 2px 6px;
            }
            
            /* Bot√£o comprar fileira - acima do footer */
            #buy-row-container {
                position: fixed !important;
                bottom: 100px !important;
                left: 50% !important;
                transform: translateX(-50%) !important;
                z-index: 99 !important;
                margin: 0 !important;
            }
            
            #buy-row-btn {
                padding: 10px 24px !important;
                font-size: 0.85rem !important;
                font-weight: bold !important;
                box-shadow: 0 4px 15px rgba(187, 134, 252, 0.4) !important;
            }
            
            .choose-row-btn {
                padding: 8px 16px;
                font-size: 0.85rem;
            }
            
            .timer-display {
                font-size: 0.9rem;
            }
            
            /* Header do modo escolha de fileira */
            #choose-row-header {
                padding: 5px !important;
                margin-bottom: 5px !important;
            }
            
            #choose-row-header > div:first-child {
                font-size: 0.9rem !important;
            }
            
            #choose-row-timer {
                font-size: 1.2rem !important;
                margin-top: 2px !important;
            }
        }
        
        /* Bot√£o placar header - ocultar no desktop */
        .mobile-placar-header-btn {
            display: none;
        }
        
        /* --- Modo de Sele√ß√£o de Fileira no Mobile --- */
        @media (max-width: 768px) {
            body.choosing-row .game-area {
                padding-bottom: 140px !important;
            }
            
            body.choosing-row .board {
                max-height: none !important;
                overflow-y: visible !important;
                padding: 4px;
            }
            
            body.choosing-row .row-wrapper {
                gap: 6px;
                margin-bottom: 3px;
            }
            
            body.choosing-row .radio-label {
                width: 20px;
                height: 20px;
            }
            
            body.choosing-row .card {
                width: 32px !important;
                height: 46px !important;
            }
            
            body.choosing-row .card-number {
                font-size: 0.85rem;
            }
            
            body.choosing-row .card-dots {
                font-size: 3px;
                line-height: 3px;
            }
            
            body.choosing-row .slot {
                width: 32px;
                height: 46px;
            }
            
            body.choosing-row .row {
                height: 54px;
                padding: 3px;
                gap: 3px;
            }
            
            body.choosing-row #buy-row-container {
                bottom: 105px !important;
            }
        }
        
        @media (max-width: 480px) {
            body.choosing-row .radio-label {
                width: 18px;
                height: 18px;
            }
            
            body.choosing-row .row-radio:checked + .radio-label::after {
                width: 6px;
                height: 6px;
            }
            
            body.choosing-row .card {
                width: 28px !important;
                height: 40px !important;
            }
            
            body.choosing-row .card-number {
                font-size: 0.75rem;
            }
            
            body.choosing-row .slot {
                width: 28px;
                height: 40px;
            }
            
            body.choosing-row .row {
                height: 48px;
                padding: 3px;
                gap: 2px;
            }
        }
        
        /* --- Responsividade Mobile Pequeno --- */
        @media (max-width: 480px) {
            :root {
                --card-w: 36px;
                --card-h: 52px;
                --row-gap: 3px;
                --row-h: 60px;
                --row-padding: 4px;
            }
            
            .lobby-container {
                padding: 15px;
            }
            
            .lobby-title {
                font-size: 1.2rem;
            }
            
            .input-group input {
                padding: 10px;
                font-size: 14px;
            }
            
            .btn {
                padding: 10px 15px;
                font-size: 0.85rem;
            }
            
            .card-number {
                font-size: 0.95rem;
            }
            
            .score-entry {
                min-width: 80px;
                padding: 6px;
                font-size: 0.75rem;
            }
            
            .score-name {
                max-width: 60px;
            }
            
            .radio-label {
                width: 20px;
                height: 20px;
                border-width: 2px;
            }
            
            .row-radio:checked + .radio-label::after {
                width: 8px;
                height: 8px;
            }
            
            header h1 {
                font-size: 0.95rem;
            }
            
            #status-bar {
                font-size: 0.7rem;
                padding: 4px 6px;
                min-height: 24px;
            }
            
            /* Cartas da m√£o ainda menores em telas pequenas */
            .hand .card {
                width: 28px !important;
                height: 40px !important;
            }
            
            .hand .card .card-number {
                font-size: 0.8rem;
            }
            
            .hand .card .card-dots {
                font-size: 2.5px;
                line-height: 2.5px;
            }
            
            .game-area {
                padding-bottom: 85px;
            }
            
            .player-area {
                padding: 5px 4px 6px 4px !important;
            }
            
            .player-area > div:first-child {
                margin-bottom: 3px !important;
                font-size: 0.55rem !important;
            }
            
            .hand {
                gap: 2px;
            }
            
            #buy-row-container {
                bottom: 95px !important;
            }
            
            #buy-row-btn {
                padding: 8px 20px !important;
                font-size: 0.8rem !important;
            }
            
            .mobile-placar-header-btn {
                padding: 4px 8px;
                font-size: 0.65rem;
            }
        }

        /* --- Game Styles (from original) --- */
        .main-layout {
            display: flex;
            width: 95%;
            max-width: 1000px;
            height: calc(100vh - 60px);
            gap: 15px;
            margin-top: 10px;
            align-items: flex-start;
        }

        .game-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
            height: 100%;
            justify-content: center;
            overflow: hidden;
        }

        .sidebar {
            width: 180px;
            background-color: var(--sidebar-color);
            border-radius: 12px;
            padding: 15px;
            border: 1px solid rgba(255,255,255,0.05);
            display: flex;
            flex-direction: column;
            gap: 10px;
            height: calc(100% - 32px);
            box-shadow: -5px 0 15px rgba(0,0,0,0.3);
            overflow-y: auto;
        }

        header { text-align: center; width: 100%; padding-top: 10px; flex-shrink: 0;}
        h1 { margin: 0; font-weight: 300; letter-spacing: 2px; font-size: 1.4rem; color: var(--text-secondary); text-transform: uppercase; }
        .subtitle { font-size: 0.75rem; color: var(--accent-color); opacity: 0.8; letter-spacing: 1px; }

        #status-bar {
            background-color: var(--surface-color);
            padding: 8px;
            border-radius: 6px;
            text-align: center;
            font-weight: 400;
            font-size: 0.9rem;
            color: var(--text-secondary);
            border: 1px solid rgba(255,255,255,0.05);
            transition: all 0.3s ease;
            flex-shrink: 0;
            min-height: 36px;
            display: flex; align-items: center; justify-content: center;
        }
        .status-action { border-color: var(--accent-color) !important; color: var(--accent-color) !important; }
        .status-error { border-color: var(--danger-color) !important; color: var(--danger-color) !important; }

        .scoreboard-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding-bottom: 5px;
        }
        
        .scoreboard-title { 
            font-size: 1rem; 
            font-weight: 600; 
            color: var(--text-primary); 
        }
        
        .toggle-placar-btn {
            display: none;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 0.8rem;
            padding: 4px 8px;
        }
        
        .round-info {
            margin-top: auto;
            font-size: 0.75rem;
            color: var(--text-secondary);
            text-align: center;
            min-width: 60px;
        }
        
        /* Bot√£o flutuante para mobile */
        .mobile-placar-btn {
            display: none;
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: 25px;
            padding: 12px 20px;
            font-size: 0.9rem;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(187, 134, 252, 0.4);
            z-index: 1000;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .mobile-placar-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(187, 134, 252, 0.6);
        }
        
        /* Modal do placar para mobile */
        .mobile-placar-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }
        
        .mobile-placar-modal.show {
            display: flex;
        }
        
        .mobile-placar-content {
            background: var(--surface-color);
            border-radius: 16px;
            padding: 20px;
            width: 90%;
            max-width: 350px;
            max-height: 80vh;
            overflow-y: auto;
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .mobile-placar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--accent-color);
        }
        
        .mobile-placar-close {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 5px 10px;
        }
        
        .mobile-placar-close:hover {
            color: var(--text-primary);
        }
        
        .mobile-round-info {
            margin-top: 15px;
            text-align: center;
            color: var(--text-secondary);
            font-size: 0.9rem;
        }
        
        .score-entry {
            display: flex; justify-content: space-between; align-items: center;
            padding: 8px; background: rgba(255,255,255,0.03); border-radius: 6px;
            font-size: 0.85rem; transition: transform 0.2s;
        }
        .score-entry.leader { border-left: 2px solid var(--accent-color); background: linear-gradient(90deg, rgba(187,134,252,0.1) 0%, transparent 100%); }
        .score-entry.danger { border-left: 2px solid var(--danger-color); }
        .score-entry.human { border: 1px solid rgba(255,255,255,0.2); }
        .score-name { font-weight: 500; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 90px; }
        .score-val { font-weight: bold; }

        .bots-action-area {
            display: flex; justify-content: center; gap: 10px; min-height: 30px; flex-shrink: 0;
        }
        .bot-action-card {
            background: rgba(0,0,0,0.3); padding: 4px 12px; border-radius: 15px;
            color: var(--text-secondary); font-size: 0.8rem; display: flex; align-items: center; gap: 6px;
            opacity: 0; transform: translateY(10px); transition: all 0.3s;
        }
        .bot-action-card.visible { opacity: 1; transform: translateY(0); }
        .bot-action-card strong { color: var(--text-primary); font-size: 0.9rem; }

        .board {
            background-color: var(--surface-color);
            padding: 10px;
            border-radius: 12px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            gap: 6px;
            border: 1px solid rgba(255,255,255,0.05);
            align-self: center;
            width: fit-content;
            max-height: none;
            overflow-y: visible;
        }

        .row {
            display: flex;
            align-items: center;
            height: var(--row-h);
            width: calc((6 * var(--card-w)) + (5 * var(--row-gap)) + (2 * var(--row-padding))); 
            background-color: rgba(0,0,0,0.2);
            border-radius: 8px;
            padding: 0 var(--row-padding);
            border: 1px solid rgba(255,255,255,0.02);
            transition: background-color 0.3s, border-color 0.3s; 
            gap: var(--row-gap);
        }

        .row-wrapper {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 10px;
        }
        
        .row-radio {
            display: none;
        }
        
        .radio-label {
            width: 28px;
            height: 28px;
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            flex-shrink: 0;
        }
        
        .radio-label:hover {
            border-color: var(--accent-color);
            background: rgba(187, 134, 252, 0.1);
        }
        
        .row-radio:checked + .radio-label {
            border-color: var(--accent-color);
            background: var(--accent-color);
        }
        
        .row-radio:checked + .radio-label::after {
            content: '';
            width: 12px;
            height: 12px;
            background: white;
            border-radius: 50%;
        }
        
        .row.selectable { 
            background-color: rgba(187, 134, 252, 0.15); 
            border-color: var(--accent-color); 
            border-width: 2px; 
            box-shadow: 0 0 12px rgba(187, 134, 252, 0.4); 
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .row.selectable:hover {
            border-width: 3px;
            box-shadow: 0 0 16px rgba(187, 134, 252, 0.6);
        }
        
        .row.selected {
            background-color: rgba(187, 134, 252, 0.3);
            border-color: var(--accent-color);
            border-width: 3px;
            box-shadow: 0 0 20px rgba(187, 134, 252, 0.8);
        }
        

        .row.full-danger { border: 1px solid rgba(207, 102, 121, 0.3); background: linear-gradient(90deg, rgba(207,102,121,0.05) 0%, transparent 100%); }

        .slot {
            width: var(--card-w);
            height: var(--card-h);
            border-radius: 5px;
            flex-shrink: 0;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .slot.empty {
            border: 1px dashed rgba(255,255,255,0.1);
            background-color: rgba(255,255,255,0.02);
        }

        .slot.sixth {
            border: 1px dashed rgba(207, 102, 121, 0.3); 
            background-color: rgba(207, 102, 121, 0.05);
            color: rgba(207, 102, 121, 0.3);
            font-size: 0.8rem;
        }
        
        .slot.sixth::after {
            content: "VI";
            font-weight: bold;
            opacity: 0.5;
        }

        .row.full-danger .slot.sixth {
            border-color: var(--danger-color);
            background-color: rgba(207, 102, 121, 0.2);
            color: var(--danger-color);
            box-shadow: 0 0 8px rgba(207, 102, 121, 0.2);
            animation: pulse-danger 1.5s infinite;
        }
        
        @keyframes pulse-danger {
            0% { opacity: 0.6; }
            50% { opacity: 1; transform: scale(1.05); }
            100% { opacity: 0.6; }
        }

        .card {
            width: var(--card-w);
            height: var(--card-h);
            border-radius: 5px;
            display: flex; flex-direction: column; justify-content: space-between; align-items: center;
            background-color: #2c2c2c; color: #ecf0f1;
            box-shadow: 0 3px 5px rgba(0,0,0,0.3);
            position: relative; 
            padding: 4px 2px;
            border: 1px solid rgba(255,255,255,0.05);
            flex-shrink: 0;
            z-index: 2;
            transition: transform 0.2s;
        }
        
        .card-number { font-size: 1.1rem; font-weight: 300; letter-spacing: -1px; }
        
        .card-dots {
            font-size: 5px; line-height: 5px; text-align: center;
            color: var(--tdb-low); display: flex; flex-wrap: wrap; justify-content: center; gap: 1px; max-width: 100%;
        }

        .card.risk-low .card-dots { color: var(--tdb-low); }
        .card.risk-med .card-dots { color: var(--tdb-med); }
        .card.risk-high .card-dots { color: var(--tdb-high); }
        .card.risk-med { border-bottom: 2px solid var(--tdb-med); }
        .card.risk-high { border-bottom: 2px solid var(--tdb-high); }

        .player-area {
            background-color: var(--surface-color);
            padding: 10px;
            border-radius: 12px;
            margin-top: auto;
            border: 1px solid rgba(255,255,255,0.05);
            flex-shrink: 0;
            width: 100%;
            max-width: 600px;
            align-self: center;
            min-height: 100px; 
            display: flex; flex-direction: column; justify-content: center;
        }

        .hand {
            display: flex; flex-wrap: wrap; gap: 6px; justify-content: center; 
        }

        .hand .card { cursor: pointer; background-color: #333; }
        .hand .card:hover { transform: translateY(-5px); background-color: #3a3a3a; border-color: rgba(255,255,255,0.2); z-index: 10;}
        .hand .card.disabled { opacity: 0.3; cursor: not-allowed; transform: none; filter: grayscale(100%); }

        #overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); backdrop-filter: blur(5px);
            display: none; justify-content: center; align-items: center; z-index: 1000;
        }
        .modal-content {
            background: var(--surface-color); color: var(--text-primary);
            padding: 30px; border-radius: 12px; text-align: center; max-width: 400px;
            border: 1px solid rgba(255,255,255,0.1); box-shadow: 0 20px 50px rgba(0,0,0,0.5);
        }
        button {
            background-color: transparent; color: var(--text-primary); border: 1px solid var(--text-primary);
            padding: 10px 25px; font-size: 0.85rem; border-radius: 50px; cursor: pointer; margin-top: 20px;
            transition: all 0.3s; text-transform: uppercase;
        }
        button:hover { background-color: var(--text-primary); color: var(--bg-color); }

    </style>
</head>
<body>

    <!-- Lobby Screen -->
    <div id="lobby-screen">
        <div class="lobby-container">
            <h1 class="lobby-title">PEGUIN 6</h1>
            <div class="lobby-subtitle">Jogue online com seus amigos</div>

            <div id="lobby-form">
                <div class="input-group">
                    <label for="player-name">Seu Nome</label>
                    <input type="text" id="player-name" placeholder="Digite seu nome" maxlength="20" value="">
                </div>

                <div class="btn-group">
                    <button class="btn btn-primary" onclick="createRoom()">Criar Sala</button>
                    <button class="btn" onclick="showJoinForm()">Entrar em Sala</button>
                </div>

                <div id="join-form" style="display: none; margin-top: 20px;">
                    <div class="input-group">
                        <label for="room-code">C√≥digo da Sala</label>
                        <input type="text" id="room-code" placeholder="Digite o c√≥digo" maxlength="6" style="text-transform: uppercase;">
                    </div>
                    <button class="btn btn-primary" style="width: 100%;" onclick="joinRoom()">Entrar</button>
                    <button class="btn" style="width: 100%; margin-top: 10px;" onclick="hideJoinForm()">Cancelar</button>
                </div>
            </div>

            <div class="room-info" id="room-info">
                <div style="text-align: center; margin-bottom: 10px; font-size: 0.9rem; color: var(--text-secondary);">
                    Compartilhe o c√≥digo da sala:
                </div>
                <div class="room-code" id="room-code-display" style="cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 10px;" onclick="copyRoomCode()" title="Clique para copiar">
                    <span id="room-code-text"></span>
                    <span style="font-size: 0.8rem; color: var(--text-secondary);">üìã</span>
                </div>
                <div class="room-link">
                    <input type="text" id="room-link-input" readonly>
                    <button onclick="copyLink()">Copiar</button>
                </div>
                <div class="players-list" id="players-list">
                    <div style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 10px;">Jogadores na sala:</div>
                    <div id="players-list-content"></div>
                </div>
                <div style="margin-top: 15px; padding: 15px; background: rgba(0,0,0,0.2); border-radius: 8px; border: 1px solid rgba(255,255,255,0.05);">
                    <div style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 10px; text-align: center;">ü§ñ Gerenciar Bots</div>
                    <div style="display: flex; gap: 10px;">
                        <button class="btn" style="flex: 1;" id="add-bot-btn" onclick="addBotToRoom()">‚ûï Adicionar</button>
                        <button class="btn" style="flex: 1;" id="remove-bot-btn" onclick="removeBotFromRoom()">‚ûñ Remover</button>
                    </div>
                    <div id="bot-count" style="text-align: center; margin-top: 8px; font-size: 0.75rem; color: var(--text-secondary);"></div>
                </div>
                <button class="btn btn-primary" style="width: 100%; margin-top: 15px;" id="start-game-btn" onclick="startGame()" disabled>Iniciar Jogo</button>
                <button class="btn" style="width: 100%; margin-top: 10px; border-color: rgba(255,255,255,0.2);" onclick="exitGame()">Voltar ao In√≠cio</button>
            </div>

            <div class="error-message" id="error-message"></div>
        </div>
    </div>

    <!-- Game Screen -->
    <div id="game-screen">
        <header>
            <div style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
                <h1>Peguin 6</h1>
                <div style="display: flex; gap: 8px; align-items: center;">
                    <button class="mobile-placar-header-btn" id="mobile-placar-header-btn" onclick="toggleMobilePlacar()">Placar</button>
                    <button class="btn" style="padding: 8px 12px; font-size: 0.8rem; margin: 0;" onclick="showGameMenu()">Menu</button>
                </div>
            </div>
            <div class="subtitle">LIMITE: 66 PTS</div>
        </header>
        
        <!-- Game Menu -->
        <div id="game-menu" style="display: none; position: fixed; top: 60px; right: 10px; background: var(--surface-color); border: 1px solid var(--accent-color); border-radius: 8px; padding: 10px; z-index: 1000; min-width: 150px;">
            <button class="btn" style="width: 100%; margin-bottom: 5px; padding: 8px; font-size: 0.8rem;" id="restart-game-btn-menu" onclick="requestRestart()">Reiniciar Jogo</button>
            <button class="btn" style="width: 100%; margin-bottom: 5px; padding: 8px; font-size: 0.8rem;" onclick="surrenderGame()">Desistir</button>
            <button class="btn" style="width: 100%; padding: 8px; font-size: 0.8rem;" onclick="exitGame()">Sair para Menu</button>
        </div>

        <div class="main-layout">
            <div class="game-area">
                <div id="status-bar">Aguardando jogadores...</div>
                <div class="bots-action-area" id="bots-action-area"></div>
                <div id="choose-row-header" style="display: none; text-align: center; margin-bottom: 15px;">
                    <div style="font-size: 1.2rem; font-weight: bold; color: var(--accent-color); text-transform: uppercase;">Selecione a Fileira</div>
                    <div id="choose-row-timer" style="font-size: 1.5rem; font-weight: bold; color: #ff6b6b; margin-top: 5px;">30</div>
                </div>
                <div class="board" id="board">
                    <div class="row-wrapper" id="row-wrapper-0">
                        <input type="radio" name="row-select" class="row-radio" id="radio-row-0" value="0" style="display: none;" onchange="selectRow(0)">
                        <label for="radio-row-0" class="radio-label" id="radio-label-0" style="display: none;"></label>
                        <div class="row" id="row-0"></div>
                    </div>
                    <div class="row-wrapper" id="row-wrapper-1">
                        <input type="radio" name="row-select" class="row-radio" id="radio-row-1" value="1" style="display: none;" onchange="selectRow(1)">
                        <label for="radio-row-1" class="radio-label" id="radio-label-1" style="display: none;"></label>
                        <div class="row" id="row-1"></div>
                    </div>
                    <div class="row-wrapper" id="row-wrapper-2">
                        <input type="radio" name="row-select" class="row-radio" id="radio-row-2" value="2" style="display: none;" onchange="selectRow(2)">
                        <label for="radio-row-2" class="radio-label" id="radio-label-2" style="display: none;"></label>
                        <div class="row" id="row-2"></div>
                    </div>
                    <div class="row-wrapper" id="row-wrapper-3">
                        <input type="radio" name="row-select" class="row-radio" id="radio-row-3" value="3" style="display: none;" onchange="selectRow(3)">
                        <label for="radio-row-3" class="radio-label" id="radio-label-3" style="display: none;"></label>
                        <div class="row" id="row-3"></div>
                    </div>
                </div>
                <div id="buy-row-container" style="display: none; text-align: center; margin-top: 20px;">
                    <button class="btn btn-primary" id="buy-row-btn" onclick="confirmRowPurchase()" style="padding: 12px 40px; font-size: 1rem; font-weight: bold;" disabled>COMPRAR FILEIRA</button>
                </div>
                <div class="player-area">
                    <div style="margin-bottom:5px; color:var(--text-secondary); font-size:0.8rem; text-align:center;">SUA M√ÉO</div>
                    <div class="hand" id="player-hand"></div>
                </div>
                
                <!-- Placar inline para mobile (abaixo da m√£o) -->
                <div class="mobile-inline-placar" id="mobile-inline-placar" style="display: none;">
                    <div style="margin: 20px 0 10px; padding: 10px; background: var(--sidebar-color); border-radius: 8px;">
                        <div style="font-size: 1rem; font-weight: bold; color: var(--accent-color); text-align: center; margin-bottom: 10px;">PLACAR</div>
                        <div id="mobile-inline-scoreboard-list"></div>
                        <div style="margin-top: 10px; text-align: center; color: var(--text-secondary); font-size: 0.85rem;">Rodada: <span id="mobile-inline-round-num">1</span></div>
                    </div>
                </div>
            </div>

            <aside class="sidebar" id="sidebar">
                <div class="scoreboard-header">
                    <div class="scoreboard-title">PLACAR</div>
                    <button class="toggle-placar-btn" id="toggle-placar-btn" onclick="togglePlacar()">
                        <span id="toggle-placar-icon">‚ñº</span>
                    </button>
                </div>
                <div id="scoreboard-content">
                    <div id="scoreboard-list"></div>
                </div>
                <div class="round-info">
                    R <span id="round-num">1</span>
                </div>
            </aside>
            
            <!-- Bot√£o flutuante para mobile -->
            <button class="mobile-placar-btn" id="mobile-placar-btn" onclick="toggleMobilePlacar()">
                üèÜ PLACAR
            </button>
            
            <!-- Modal do placar para mobile -->
            <div class="mobile-placar-modal" id="mobile-placar-modal">
                <div class="mobile-placar-content">
                    <div class="mobile-placar-header">
                        <span>PLACAR</span>
                        <button class="mobile-placar-close" onclick="toggleMobilePlacar()">‚úï</button>
                    </div>
                    <div id="mobile-scoreboard-list"></div>
                    <div class="mobile-round-info">Rodada: <span id="mobile-round-num">1</span></div>
                </div>
            </div>
        </div>
    </div>

    <!-- End Game Overlay -->
    <div id="overlay" style="display: none;">
        <div class="modal-content" style="max-width: 500px;">
            <h2 id="end-title" style="font-size: 2rem; margin-bottom: 10px; color: var(--accent-color);">Fim de Jogo!</h2>
            <div id="end-winner" style="font-size: 1.3rem; margin-bottom: 20px; font-weight: bold;"></div>
            <div id="end-ranking" style="margin-top: 20px; line-height: 2; text-align: left; background: rgba(0,0,0,0.3); padding: 20px; border-radius: 8px;"></div>
            <button class="btn btn-primary" onclick="playAgain()" style="padding: 12px 40px; font-size: 1rem; margin-top: 20px;">JOGAR NOVAMENTE</button>
        </div>
    </div>

<script>
    // --- Configura√ß√µes ---
    const TOTAL_CARDS = 104;
    const ROW_COUNT = 4;
    const MAX_ROW_LENGTH = 5;
    const SCORE_LIMIT = 66;
    // Detecta automaticamente a URL do WebSocket
    function getWebSocketURL() {
        const hostname = window.location.hostname;
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const port = window.location.port || (protocol === 'wss:' ? '443' : '80');
        
        // Se for localhost, usa localhost:3000
        if (hostname === 'localhost' || hostname === '127.0.0.1') {
            return 'ws://localhost:3000/ws';
        }
        
        // Caso contr√°rio, usa a mesma URL do navegador
        return `${protocol}//${hostname}${port && port !== '80' && port !== '443' ? ':' + port : ''}/ws`;
    }
    
    const WS_URL = getWebSocketURL();

    // --- Estado Global ---
    let ws = null;
    let playerId = null;
    let playerName = '';
    let roomId = null;
    let isHost = false;
    let players = [];
    let deck = [];
    let boardRows = [[], [], [], []];
    let currentTurn = 1;
    let gameState = "LOBBY";
    let roundSelections = [];
    let pendingPlayerCard = null;
    let myPlayerIndex = -1;
    let selectedRowIndex = null; // √çndice da fileira selecionada para compra
    let chooseRowTimer = null; // Timer para escolha de fileira
    let chooseRowTimeLeft = 30; // Segundos restantes para escolher
    let playerTurnTimer = null; // Timer para jogada do jogador
    let playerTurnTimeLeft = 30; // Segundos para o jogador jogar
    let waitingRecoveryTimer = null; // Timer para recupera√ß√£o de estados travados
    let stateCheckInterval = null; // Intervalo para verifica√ß√£o peri√≥dica de estado

    // --- WebSocket Connection ---
    function connectWebSocket() {
        ws = new WebSocket(WS_URL);

        ws.onopen = () => {
            console.log('Conectado ao servidor');
        };

        ws.onmessage = (event) => {
            const data = JSON.parse(event.data);
            handleWebSocketMessage(data);
        };

        ws.onerror = (error) => {
            showError('Erro de conex√£o. Certifique-se de que o servidor est√° rodando.');
            console.error('WebSocket error:', error);
        };

        ws.onclose = () => {
            console.log('Desconectado do servidor');
            setTimeout(() => {
                if (gameState !== 'END') {
                    showError('Conex√£o perdida. Tentando reconectar...');
                    connectWebSocket();
                }
            }, 3000);
        };
    }

    function handleWebSocketMessage(data) {
        switch (data.type) {
            case 'ROOM_CREATED':
                roomId = data.payload.roomId;
                playerId = data.payload.playerId;
                isHost = true;
                // Adicionar o host √† lista de players
                players = [{
                    id: playerId,
                    name: data.payload.playerName,
                    isBot: false,
                    hand: [],
                    score: 0,
                    lastPlayed: null
                }];
                updatePlayersList([{ id: playerId, name: data.payload.playerName }]);
                showRoomInfo();
                break;

            case 'JOIN_CONFIRMED':
                // Convidado recebe seu playerId do servidor
                playerId = data.payload.playerId;
                roomId = data.payload.roomId;
                console.log('JOIN_CONFIRMED - playerId:', playerId, 'roomId:', roomId);
                showRoomInfo();
                break;

            case 'PLAYER_JOINED':
                updatePlayersList(data.payload.players);
                if (isHost) {
                    document.getElementById('start-game-btn').disabled = data.payload.players.length < 2;
                }
                break;

            case 'PLAYER_LEFT':
                updatePlayersList(data.payload.players);
                if (isHost) {
                    document.getElementById('start-game-btn').disabled = data.payload.players.length < 2;
                }
                break;

            case 'GAME_STARTED':
                // Usar as informa√ß√µes de bot enviadas pelo servidor
                players = data.payload.players.map((p, idx) => {
                    return {
                        id: p.id,
                        name: p.name,
                        isBot: p.isBot || false,
                        hand: [],
                        score: 0,
                        lastPlayed: null
                    };
                });
                myPlayerIndex = players.findIndex(p => p.id === playerId);
                console.log('GAME_STARTED - myPlayerIndex:', myPlayerIndex, 'playerId:', playerId, 'players:', players);
                startNewRound();
                break;

            case 'GAME_UPDATE':
                handleGameUpdate(data.payload);
                break;

            case 'GAME_STATE_UPDATE':
                syncGameState(data.payload.gameState);
                break;

            case 'ERROR':
                showError(data.payload.message);
                break;
                
            case 'BOTS_UPDATED':
                console.log('BOTS_UPDATED - received new players list:', data.payload.players.map(p => p.name + (p.isBot ? ' (bot)' : '')));
                updatePlayersList(data.payload.players);
                if (isHost) {
                    document.getElementById('start-game-btn').disabled = data.payload.players.length < 2;
                }
                break;
        }
    }

    // --- Lobby Functions ---
    function createRoom() {
        const name = document.getElementById('player-name').value.trim();
        if (!name) {
            showError('Por favor, digite seu nome');
            return;
        }
        playerName = name;
        connectWebSocket();
        ws.onopen = () => {
            ws.send(JSON.stringify({
                type: 'CREATE_ROOM',
                payload: { playerName: name }
            }));
        };
    }

    function showJoinForm() {
        const name = document.getElementById('player-name').value.trim();
        if (!name) {
            showError('Por favor, digite seu nome primeiro');
            return;
        }
        playerName = name;
        document.getElementById('join-form').style.display = 'block';
    }

    function hideJoinForm() {
        document.getElementById('join-form').style.display = 'none';
        document.getElementById('room-code').value = '';
    }
    
    function joinRoom() {
        const code = document.getElementById('room-code').value.trim().toUpperCase();
        if (!code) {
            showError('Por favor, digite o c√≥digo da sala');
            return;
        }
        connectWebSocket();
        ws.onopen = () => {
            ws.send(JSON.stringify({
                type: 'JOIN_ROOM',
                payload: { roomId: code, playerName: playerName }
            }));
        };
    }

    function showRoomInfo() {
        document.getElementById('lobby-form').style.display = 'none';
        document.getElementById('room-info').classList.add('show');
        document.getElementById('room-code-text').textContent = roomId;
        const fullLink = window.location.href.split('?')[0] + '?room=' + roomId;
        document.getElementById('room-link-input').value = fullLink;
    }

    function updatePlayersList(playersList) {
        console.log('updatePlayersList - received:', playersList.map(p => p.name + (p.isBot ? ' (bot)' : '')));
        
        // Atualizar a vari√°vel players global preservando dados locais
        const newPlayers = playersList.map(p => {
            // Verificar se j√° existe esse jogador localmente
            const existing = players.find(ep => ep.id === p.id);
            return {
                id: p.id,
                name: p.name,
                isBot: p.isBot || false,
                hand: existing?.hand || p.hand || [],
                score: existing?.score || p.score || 0,
                lastPlayed: existing?.lastPlayed || p.lastPlayed || null
            };
        });
        players = newPlayers;
        
        const container = document.getElementById('players-list-content');
        container.innerHTML = '';
        playersList.forEach(p => {
            const div = document.createElement('div');
            div.className = 'player-item';
            if (p.id === playerId && isHost) div.classList.add('host');
            div.textContent = p.name + (p.isBot ? ' ü§ñ' : '');
            container.appendChild(div);
        });
        
        // Atualizar contador de bots
        const botCount = playersList.filter(p => p.isBot).length;
        const humanCount = playersList.length - botCount;
        const botCountEl = document.getElementById('bot-count');
        if (botCountEl) {
            botCountEl.textContent = `${humanCount} jogador(es) ‚Ä¢ ${botCount} bot(s)`;
        }
        
        // Desabilitar bot√µes se necess√°rio
        const addBotBtn = document.getElementById('add-bot-btn');
        const removeBotBtn = document.getElementById('remove-bot-btn');
        if (addBotBtn) addBotBtn.disabled = playersList.length >= 10;
        if (removeBotBtn) removeBotBtn.disabled = botCount === 0;
    }

    function copyLink() {
        const input = document.getElementById('room-link-input');
        input.select();
        document.execCommand('copy');
        const btn = event.target;
        const originalText = btn.textContent;
        btn.textContent = 'Copiado!';
        setTimeout(() => {
            btn.textContent = originalText;
        }, 2000);
    }
    
    function copyRoomCode() {
        const code = roomId;
        if (!code) return;
        
        if (navigator.clipboard) {
            navigator.clipboard.writeText(code).then(() => {
                const display = document.getElementById('room-code-display');
                const originalHTML = display.innerHTML;
                display.innerHTML = '<span style="color: var(--accent-color);">Copiado!</span>';
                setTimeout(() => {
                    display.innerHTML = originalHTML;
                }, 2000);
            });
        } else {
            const textarea = document.createElement('textarea');
            textarea.value = code;
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand('copy');
            document.body.removeChild(textarea);
        }
    }

    function startGame() {
        if (!isHost) return;
        if (players.length < 2) {
            showError('Precisa de pelo menos 2 jogadores');
            return;
        }
        ws.send(JSON.stringify({
            type: 'START_GAME',
            payload: {
                players: players.map(p => ({ id: p.id, name: p.name, isBot: p.isBot }))
            }
        }));
    }
    
    function addBotToRoom() {
        if (!isHost) return;
        if (players.length >= 10) {
            showError('M√°ximo de 10 jogadores');
            return;
        }
        
        const botId = 'bot-' + Math.random().toString(36).substr(2, 9);
        const botName = 'Bot ' + (players.length);
        
        const newBot = {
            id: botId,
            name: botName,
            isBot: true,
            hand: [],
            score: 0,
            lastPlayed: null
        };
        players.push(newBot);
        updatePlayersList(players);
        
        // Sincronizar com outros jogadores
        ws.send(JSON.stringify({
            type: 'UPDATE_BOTS',
            payload: {
                players: players.map(p => ({ id: p.id, name: p.name, isBot: p.isBot }))
            }
        }));
        
        // Habilitar botao de iniciar se tiver 2+ jogadores
        const startBtn = document.getElementById('start-game-btn');
        if (startBtn && players.length >= 2) {
            startBtn.disabled = false;
        }
    }

    function removeBotFromRoom() {
        if (!isHost) return;
        let botIndex = -1;
        for (let i = players.length - 1; i >= 0; i--) {
            if (players[i].isBot) {
                botIndex = i;
                break;
            }
        }
        
        if (botIndex !== -1) {
            players.splice(botIndex, 1);
            updatePlayersList(players);
            
            // Sincronizar com outros jogadores
            ws.send(JSON.stringify({
                type: 'UPDATE_BOTS',
                payload: {
                    players: players.map(p => ({ id: p.id, name: p.name, isBot: p.isBot }))
                }
            }));
        }
        
        // Desabilitar botao de iniciar se tiver menos de 2 jogadores
        const startBtn = document.getElementById('start-game-btn');
        if (startBtn && players.length < 2) {
            startBtn.disabled = true;
        }
    }

    function showError(message) {
        const errorDiv = document.getElementById('error-message');
        errorDiv.textContent = message;
        errorDiv.classList.add('show');
        setTimeout(() => {
            errorDiv.classList.remove('show');
        }, 5000);
    }

    // --- Game Functions ---
    function calculateTdB(num) {
        let tdb = 1;
        if (num % 10 === 0) tdb = 3;
        else if (num % 5 === 0) tdb = 2;
        if (num > 10 && num < 100 && Math.floor(num/10) === (num%10)) tdb += 5;
        return tdb;
    }

    function startNewRound() {
        console.log('startNewRound - isHost:', isHost, 'myPlayerIndex:', myPlayerIndex, 'players:', players.length);
        document.getElementById('lobby-screen').style.display = 'none';
        document.getElementById('game-screen').classList.add('show');

        // IMPORTANTE: Apenas o host cria e distribui o deck
        // Jogadores n√£o-host recebem as cartas via GAME_STATE_SYNC
        if (isHost) {
            deck = [];
            for (let i = 1; i <= TOTAL_CARDS; i++) deck.push({ number: i, tdb: calculateTdB(i) });
            
            // Shuffle
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
            
            console.log('startNewRound - host created and shuffled deck, total cards:', deck.length);

            // Deal cards (only host generates and distributes)
            const hands = [];
            for (let p = 0; p < players.length; p++) {
                hands[p] = [];
                for (let k = 0; k < 10; k++) hands[p].push(deck.pop());
                hands[p].sort((a,b) => a.number - b.number);
            }

            const initialRows = [];
            for (let i = 0; i < ROW_COUNT; i++) initialRows[i] = [deck.pop()];

            // Send game state to all players
            const gameState = {
                hands: hands,
                boardRows: initialRows,
                currentTurn: 1
            };

            ws.send(JSON.stringify({
                type: 'GAME_STATE_SYNC',
                payload: { gameState }
            }));

            // Apply locally
            console.log('Host applying hands locally, players:', players.length, 'hands:', hands.length);
            players.forEach((p, idx) => {
                p.hand = hands[idx];
                p.lastPlayed = null;
                console.log('Player', idx, p.name, 'hand:', p.hand.length, 'cards');
            });
            boardRows = initialRows;
            console.log('Host myPlayerIndex:', myPlayerIndex, 'my hand:', players[myPlayerIndex]?.hand?.length);
            
            // Host define estado e inicia jogo
            currentTurn = 1;
            gameState = "SELECT";
            updateUI();
            setStatus("Sua vez - escolha uma carta", "action");
            
            // Iniciar timer de jogada do jogador
            startPlayerTurnTimer();
            
            // Iniciar verifica√ß√£o peri√≥dica de estado (anti-travamento)
            startStateCheckInterval();
            
            // IMPORTANTE: Fazer bots jogarem automaticamente no in√≠cio da rodada
            setTimeout(() => triggerBotPlays(), 1000);
        } else {
            // Jogador n√£o-host: aguardar GAME_STATE_SYNC do host
            console.log('startNewRound - non-host waiting for GAME_STATE_SYNC');
            gameState = "WAITING";
            setStatus("Aguardando distribui√ß√£o de cartas...", "info");
            updateUI();
            
            // Iniciar verifica√ß√£o peri√≥dica de estado (anti-travamento)
            startStateCheckInterval();
        }
    }

    // IA para bots - escolhe uma carta estrategica
    function chooseBotCard(botHand, boardRows) {
        if (!botHand || botHand.length === 0) return null;
        const sortedHand = [...botHand].sort((a, b) => a.number - b.number);
        for (let card of sortedHand) {
            let bestRow = -1;
            let bestLastCard = -1;
            for (let i = 0; i < boardRows.length; i++) {
                const row = boardRows[i];
                if (row.length === 0) continue;
                const lastCard = row[row.length - 1].number;
                if (lastCard < card.number && lastCard > bestLastCard) {
                    bestRow = i;
                    bestLastCard = lastCard;
                }
            }
            if (bestRow !== -1 && boardRows[bestRow].length < 5) {
                return card;
            }
        }
        return sortedHand[0];
    }
    
    function makeBotPlay(botIndex) {
        const bot = players[botIndex];
        
        // Valida√ß√µes de seguran√ßa
        if (!bot) {
            console.log('makeBotPlay - bot not found at index', botIndex);
            return;
        }
        
        if (!bot.isBot) {
            console.log('makeBotPlay - player is not a bot:', bot.name);
            return;
        }
        
        if (bot.lastPlayed) {
            console.log('makeBotPlay - bot already played:', bot.name, bot.lastPlayed.number);
            return;
        }
        
        if (!bot.hand || bot.hand.length === 0) {
            console.log('makeBotPlay - bot has no cards:', bot.name);
            return;
        }
        
        const chosenCard = chooseBotCard(bot.hand, boardRows);
        if (!chosenCard) {
            console.log('makeBotPlay - no card chosen for bot', bot.name, '- hand:', bot.hand);
            // Se n√£o conseguiu escolher, pegar a primeira carta
            if (bot.hand.length > 0) {
                const fallbackCard = bot.hand[0];
                console.log('makeBotPlay - using fallback card:', fallbackCard.number);
                executeBotPlay(bot, fallbackCard, 0);
            }
            return;
        }
        
        console.log('makeBotPlay - bot', bot.name, 'playing card', chosenCard.number);
        
        const cardIndex = bot.hand.findIndex(c => c.number === chosenCard.number);
        executeBotPlay(bot, chosenCard, cardIndex);
    }
    
    function executeBotPlay(bot, card, cardIndex) {
        console.log('executeBotPlay - START - bot:', bot.name, 'card:', card.number, 'cardIndex:', cardIndex);
        
        // Verificar se WebSocket est√° conectado
        if (!ws || ws.readyState !== WebSocket.OPEN) {
            console.error('executeBotPlay - WebSocket not connected! readyState:', ws?.readyState);
            // Se n√£o estiver conectado, processar localmente apenas
            if (cardIndex !== -1 && cardIndex < bot.hand.length) {
                bot.hand.splice(cardIndex, 1);
            }
            bot.lastPlayed = card;
            updateUI();
            if (isHost) {
                setTimeout(() => checkAllPlayersPlayed(), 300);
            }
            return;
        }
        
        // Remover carta da m√£o do bot
        if (cardIndex !== -1 && cardIndex < bot.hand.length) {
            bot.hand.splice(cardIndex, 1);
            console.log('executeBotPlay - removed card from hand, remaining:', bot.hand.length);
        }
        bot.lastPlayed = card;
        console.log('executeBotPlay - set lastPlayed:', card.number);
        
        // Enviar jogada do bot para o servidor
        try {
            ws.send(JSON.stringify({
                type: 'GAME_ACTION',
                payload: {
                    action: 'PLAY_CARD',
                    cardIndex: cardIndex,
                    card: card,
                    fromPlayerId: bot.id
                }
            }));
            console.log('executeBotPlay - sent PLAY_CARD to server');
        } catch (error) {
            console.error('executeBotPlay - error sending to server:', error);
        }
        
        updateUI();
        console.log('executeBotPlay - updated UI');
        
        // Verificar se todos jogaram
        if (isHost) {
            console.log('executeBotPlay - scheduling checkAllPlayersPlayed');
            setTimeout(() => checkAllPlayersPlayed(), 300);
        }
        
        console.log('executeBotPlay - END');
    }

    function syncGameState(state) {
        if (!state) return;
        
        console.log('syncGameState - playerId:', playerId, 'players:', players.map(p => p.id));
        
        // Garantir que myPlayerIndex esteja definido
        if (myPlayerIndex === -1) {
            myPlayerIndex = players.findIndex(p => p.id === playerId);
            console.log('syncGameState - calculated myPlayerIndex:', myPlayerIndex);
        }
        
        // Aplicar as m√£os para cada jogador
        if (state.hands) {
            console.log('syncGameState - received hands for', state.hands.length, 'players');
            // Se a quantidade de m√£os recebidas for diferente da quantidade de jogadores, 
            // pode ser que a lista de jogadores esteja desatualizada
            state.hands.forEach((hand, idx) => {
                if (players[idx]) {
                    players[idx].hand = hand;
                    console.log('Player', idx, players[idx].name, 'received', hand.length, 'cards');
                }
            });
        }
        
        if (state.boardRows) {
            console.log('syncGameState - received boardRows:', state.boardRows.map(r => r.map(c => c.number)));
            boardRows = state.boardRows;
        }
        
        if (state.currentTurn) {
            currentTurn = state.currentTurn;
        }
        
        // Aplicar lastPlayed se presente (para sincroniza√ß√£o completa)
        if (state.lastPlayed) {
            console.log('syncGameState - received lastPlayed for', state.lastPlayed.length, 'players');
            state.lastPlayed.forEach((lp, idx) => {
                if (players[idx]) {
                    players[idx].lastPlayed = lp;
                }
            });
        }
        
        // Aplicar scores se presente
        if (state.scores) {
            console.log('syncGameState - received scores for', state.scores.length, 'players');
            state.scores.forEach((score, idx) => {
                if (players[idx]) {
                    players[idx].score = score;
                }
            });
        }

        console.log('syncGameState - myPlayerIndex:', myPlayerIndex, 'my hand:', players[myPlayerIndex]?.hand?.length);
        
        // Parar timer de recupera√ß√£o se estava esperando
        stopWaitingRecoveryTimer();
        
        // Verificar se o jogador tem cartas na m√£o antes de pedir escolha
        const myHand = players[myPlayerIndex]?.hand || [];
        const myPlayer = players[myPlayerIndex];
        
        if (myHand.length > 0) {
            // Verificar se j√° jogamos nesta rodada
            if (myPlayer && myPlayer.lastPlayed !== null) {
                console.log('syncGameState - already played this round, setting WAITING');
                gameState = "WAITING";
                setStatus("Aguardando outros jogadores...", "info");
            } else {
                console.log('syncGameState - have cards and not played, setting SELECT');
                gameState = "SELECT";
                setStatus("Sua vez - escolha uma carta", "action");
                // Iniciar timer de jogada do jogador
                startPlayerTurnTimer();
            }
        } else {
            // N√ÉO definir como WAITING aqui - pode ser que as cartas ainda n√£o foram distribu√≠das
            // O finishTurn j√° cuida disso
            console.log('syncGameState - player has no cards, keeping current gameState:', gameState);
        }
        
        updateUI();
        
        // Fazer bots jogarem automaticamente (apenas o host controla os bots)
        if (isHost) {
            setTimeout(() => triggerBotPlays(), 1000);
        }
    }

    function handleCardClick(cardIndex) {
        console.log('handleCardClick - cardIndex:', cardIndex, 'gameState:', gameState, 'myPlayerIndex:', myPlayerIndex);
        
        // Limpar timer de jogada
        if (playerTurnTimer) {
            clearTimeout(playerTurnTimer);
            playerTurnTimer = null;
        }
        
        if (gameState !== "SELECT") {
            console.log('handleCardClick - blocked: gameState is not SELECT, current:', gameState);
            return;
        }
        if (myPlayerIndex === -1) {
            console.log('handleCardClick - blocked: myPlayerIndex is -1');
            return;
        }

        const player = players[myPlayerIndex];
        if (!player || cardIndex >= player.hand.length) {
            console.log('handleCardClick - blocked: invalid player or cardIndex');
            return;
        }
        
        // Verificar se j√° jogou nesta rodada
        if (player.lastPlayed !== null) {
            console.warn('handleCardClick - blocked: player already played this round, lastPlayed:', player.lastPlayed.number);
            return;
        }

        const chosenCard = player.hand[cardIndex];
        
        ws.send(JSON.stringify({
            type: 'GAME_ACTION',
            payload: {
                action: 'PLAY_CARD',
                cardIndex: cardIndex,
                card: chosenCard
            }
        }));

        // Optimistic update
        player.hand.splice(cardIndex, 1);
        player.lastPlayed = chosenCard;
        gameState = "WAITING";
        updateUI();
        setStatus("Aguardando outros jogadores...");
        
        // Iniciar timer de recupera√ß√£o caso fique travado
        startWaitingRecoveryTimer();
        
        // Se sou o host, fazer bots jogarem e verificar se todos jogaram
        if (isHost) {
            console.log('handleCardClick - player played, triggering bots');
            // Primeiro fazer os bots jogarem
            setTimeout(() => triggerBotPlays(), 300);
            // Depois verificar se todos jogaram
            setTimeout(() => checkAllPlayersPlayed(), 1000);
        }
    }

    function handleGameUpdate(payload) {
        console.log('handleGameUpdate - action:', payload.action, 'fromPlayerId:', payload.fromPlayerId, 'isHost:', isHost);
        
        if (payload.action === 'PLAY_CARD') {
            const player = players.find(p => p.id === payload.fromPlayerId);
            console.log('handleGameUpdate PLAY_CARD - player found:', !!player, 'card:', payload.card?.number);
            
            if (player && payload.card) {
                const cardIndex = player.hand.findIndex(c => c.number === payload.card.number);
                console.log('handleGameUpdate PLAY_CARD - cardIndex in hand:', cardIndex);
                
                if (cardIndex !== -1) {
                    player.hand.splice(cardIndex, 1);
                }
                player.lastPlayed = payload.card;
                console.log('handleGameUpdate PLAY_CARD - updated player:', player.name, 'lastPlayed:', player.lastPlayed.number);
                updateUI();
                
                // Verificar se todos jogaram (apenas o host processa)
                if (isHost) {
                    console.log('handleGameUpdate PLAY_CARD - host checking if all played');
                    setTimeout(() => checkAllPlayersPlayed(), 500);
                } else {
                    // Jogadores n√£o-host tamb√©m precisam verificar localmente
                    console.log('handleGameUpdate PLAY_CARD - non-host checking local state');
                    const allPlayed = players.every(p => p.lastPlayed !== null);
                    console.log('handleGameUpdate PLAY_CARD - all players played?', allPlayed);
                    
                    if (allPlayed) {
                        console.log('handleGameUpdate PLAY_CARD - all played, waiting for host to process');
                        // Todos jogaram, aguardar o host processar
                        // Adicionar timeout de seguran√ßa caso o host n√£o processe
                        setTimeout(() => {
                            if (gameState === "WAITING") {
                                console.warn('handleGameUpdate PLAY_CARD - timeout waiting for host, forcing check');
                                // For√ßar verifica√ß√£o local
                                const stillAllPlayed = players.every(p => p.lastPlayed !== null);
                                if (stillAllPlayed) {
                                    console.error('handleGameUpdate PLAY_CARD - DESYNC DETECTED! Host did not process. Requesting sync.');
                                    // Solicitar sincroniza√ß√£o do host
                                    ws.send(JSON.stringify({
                                        type: 'GAME_ACTION',
                                        payload: {
                                            action: 'REQUEST_SYNC'
                                        }
                                    }));
                                }
                            }
                        }, 5000); // 5 segundos de timeout
                    }
                }
            }
        } else if (payload.action === 'CARD_PLACED') {
            // Handle card placement
            if (payload.rowIndex !== undefined && payload.card) {
                if (payload.isSixthCard) {
                    // Row was taken
                    boardRows[payload.rowIndex] = [payload.card];
                    if (payload.points !== undefined) {
                        const player = players.find(p => p.id === payload.playerId);
                        if (player) player.score += payload.points;
                    }
                } else {
                    boardRows[payload.rowIndex].push(payload.card);
                }
                updateUI();
            }
        } else if (payload.action === 'ROW_SELECTED') {
            // Handle row selection for low card
            if (payload.rowIndex !== undefined && payload.card) {
                boardRows[payload.rowIndex] = [payload.card];
                if (payload.points !== undefined) {
                    const player = players.find(p => p.id === payload.playerId);
                    if (player) player.score += payload.points;
                }
                updateUI();
                
                // Se sou o host e outro jogador escolheu, continuar processando
                if (isHost && payload.playerId !== playerId) {
                    onRowSelectionComplete();
                }
            }
        } else if (payload.action === 'CHOOSE_ROW_REQUEST') {
            // Outro jogador precisa escolher uma fileira - verificar se sou eu
            console.log('CHOOSE_ROW_REQUEST received - playerId:', payload.playerId, 'my playerId:', playerId);
            if (payload.playerId === playerId) {
                console.log('I need to choose a row!');
                pendingPlayerCard = payload.card;
                selectedRowIndex = null;
                gameState = "CHOOSE_ROW";
                setStatus("Sua carta √© menor que todas! Selecione uma fileira e clique em COMPRAR", "action");
                startChooseRowTimer(); // Iniciar timer de 30 segundos
                updateUI();
            }
        } else if (payload.action === 'TURN_END') {
            console.log('TURN_END received - resetting lastPlayed and advancing turn');
            
            // Parar timer de recupera√ß√£o
            stopWaitingRecoveryTimer();
            
            players.forEach(p => p.lastPlayed = null);
            currentTurn++;
            
            // Verificar se o jogador tem cartas na m√£o antes de pedir escolha
            const myHand = players[myPlayerIndex]?.hand || [];
            
            if (myHand.length > 0) {
                gameState = "SELECT";
                setStatus("Sua vez - escolha uma carta", "action");
                // Iniciar timer de jogada do jogador
                startPlayerTurnTimer();
            } else {
                gameState = "WAITING";
                setStatus("Aguardando distribui√ß√£o de novas cartas...", "info");
            }
            
            updateUI();
            
            // Fazer bots jogarem automaticamente (apenas o host controla os bots)
            if (isHost) {
                setTimeout(() => triggerBotPlays(), 800);
            }
        } else if (payload.action === 'ROUND_PROCESSING') {
            console.log('ROUND_PROCESSING - host is processing round, updating local state');
            // Host est√° processando o round, garantir que estamos em estado de espera
            if (gameState === "WAITING") {
                setStatus("Processando rodada...", "info");
                updateUI();
            }
        } else if (payload.action === 'REQUEST_SYNC') {
            console.log('REQUEST_SYNC received from player');
            if (isHost) {
                console.log('REQUEST_SYNC - host forcing checkAllPlayersPlayed');
                // Host for√ßa verifica√ß√£o e sincroniza√ß√£o
                checkAllPlayersPlayed();
            }
        } else if (payload.action === 'REQUEST_FULL_SYNC') {
            console.log('REQUEST_FULL_SYNC received from player');
            if (isHost) {
                console.log('REQUEST_FULL_SYNC - host sending full game state');
                // Host envia estado completo do jogo
                const fullGameState = {
                    hands: players.map(p => p.hand),
                    boardRows: boardRows,
                    currentTurn: currentTurn,
                    lastPlayed: players.map(p => p.lastPlayed),
                    scores: players.map(p => p.score)
                };
                ws.send(JSON.stringify({
                    type: 'GAME_STATE_SYNC',
                    payload: { gameState: fullGameState }
                }));
            }
        } else if (payload.action === 'RESTART_REQUEST') {
            if (confirm(`O jogador ${payload.fromPlayerName} deseja reiniciar o jogo. Voc√™ aceita?`)) {
                ws.send(JSON.stringify({
                    type: 'GAME_ACTION',
                    payload: {
                        action: 'RESTART_CONFIRMED'
                    }
                }));
            }
        } else if (payload.action === 'GAME_RESTARTED') {
            alert('O jogo foi reiniciado!');
            // Resetar estado local e iniciar nova rodada
            players.forEach(p => {
                p.score = 0;
                p.hand = [];
                p.lastPlayed = null;
            });
            currentTurn = 1;
            if (isHost) {
                startNewRound();
            }
        } else if (payload.action === 'GAME_OVER') {
            gameState = "END";
            
            // Parar todos os timers e verifica√ß√µes
            stopWaitingRecoveryTimer();
            stopStateCheckInterval();
            if (playerTurnTimer) {
                clearTimeout(playerTurnTimer);
                playerTurnTimer = null;
            }
            
            // Exibir tela de fim de jogo para todos os jogadores
            if (payload.ranking) {
                const ranking = payload.ranking;
                const winner = ranking[0]; // Primeiro do ranking (menos pontos)
                showGameOverScreen(winner, ranking);
            }
            
            setStatus(`Fim de jogo! ${payload.winner} venceu!`, "action");
            updateUI();
        }
    }

    // Verificar se todos os jogadores jogaram suas cartas
    let checkAllPlayersPlayedCalls = 0;
    function checkAllPlayersPlayed() {
        console.log('checkAllPlayersPlayed - START');
        console.log('checkAllPlayersPlayed - total players:', players.length);
        
        // Prote√ß√£o contra loops infinitos
        checkAllPlayersPlayedCalls++;
        if (checkAllPlayersPlayedCalls > 20) {
            console.error('checkAllPlayersPlayed - too many calls, resetting');
            checkAllPlayersPlayedCalls = 0;
            return;
        }
        
        players.forEach((p, idx) => {
            console.log(`checkAllPlayersPlayed - Player ${idx}: ${p.name}, isBot: ${p.isBot}, lastPlayed: ${p.lastPlayed?.number || 'null'}, handSize: ${p.hand?.length || 0}`);
        });
        
        const allPlayed = players.every(p => p.lastPlayed !== null);
        console.log('checkAllPlayersPlayed - allPlayed:', allPlayed);
        
        if (allPlayed) {
            console.log('checkAllPlayersPlayed - all players played, processing round');
            checkAllPlayersPlayedCalls = 0; // Reset counter
            // Pequeno delay para garantir que a UI atualize
            setTimeout(() => processRound(), 500);
        } else {
            console.log('checkAllPlayersPlayed - waiting for more players');
            // Verificar se h√° bots que ainda n√£o jogaram
            const botsNotPlayed = players.filter(p => p.isBot && !p.lastPlayed && p.hand && p.hand.length > 0);
            console.log('checkAllPlayersPlayed - bots not played count:', botsNotPlayed.length);
            
            if (botsNotPlayed.length > 0 && isHost) {
                console.log('checkAllPlayersPlayed - bots not played:', botsNotPlayed.map(b => b.name));
                console.log('checkAllPlayersPlayed - triggering bot plays again in 800ms');
                setTimeout(() => triggerBotPlays(), 800);
            } else {
                // Verificar se o jogador humano ainda n√£o jogou e deveria estar em SELECT
                const humanPlayer = players[myPlayerIndex];
                if (humanPlayer && !humanPlayer.isBot && !humanPlayer.lastPlayed && humanPlayer.hand && humanPlayer.hand.length > 0) {
                    console.log('checkAllPlayersPlayed - human player has not played yet, checking gameState');
                    console.log('checkAllPlayersPlayed - current gameState:', gameState);
                    
                    // Se o gameState n√£o √© SELECT, for√ßar sincroniza√ß√£o
                    if (gameState !== "SELECT") {
                        console.warn('checkAllPlayersPlayed - DESYNCHRONIZATION DETECTED! Forcing gameState to SELECT');
                        gameState = "SELECT";
                        setStatus("Sua vez - escolha uma carta", "action");
                        updateUI();
                        // Reiniciar timer de jogada
                        startPlayerTurnTimer();
                    }
                }
                // Resetar contador se n√£o h√° mais bots para jogar
                checkAllPlayersPlayedCalls = 0;
            }
        }
    }
    
    // Processar o turno - colocar cartas nas fileiras
    let pendingRowSelections = 0; // Contador de jogadores que precisam escolher fileira
    let cardsToProcess = []; // Cartas a processar
    let currentCardIndex = 0; // √çndice da carta atual sendo processada
    
    function processRound() {
        console.log('processRound - processing cards, isHost:', isHost);
        
        // IMPORTANTE: Apenas o host deve processar as cartas
        // Jogadores n√£o-host recebem os resultados via CARD_PLACED
        if (!isHost) {
            console.warn('processRound - called on non-host, ignoring!');
            return;
        }
        
        // Parar timer de recupera√ß√£o - estamos processando
        stopWaitingRecoveryTimer();
        
        // Reset do contador de chamadas recursivas
        checkAllPlayersPlayedCalls = 0;
        
        // Ordenar jogadores pela carta jogada (menor para maior)
        cardsToProcess = players.map((p, idx) => ({
            playerIndex: idx,
            playerId: p.id,
            card: p.lastPlayed
        })).sort((a, b) => a.card.number - b.card.number);
        
        currentCardIndex = 0;
        pendingRowSelections = 0;
        
        // Broadcast para todos que o processamento come√ßou
        if (isHost) {
            console.log('processRound - broadcasting ROUND_PROCESSING to all players');
            ws.send(JSON.stringify({
                type: 'GAME_ACTION',
                payload: {
                    action: 'ROUND_PROCESSING'
                }
            }));
        }
        
        // Processar a primeira carta
        processNextCard();
    }
    
    function processNextCard() {
        if (currentCardIndex >= cardsToProcess.length) {
            // Todas as cartas foram processadas
            // S√≥ finalizar o turno se n√£o houver sele√ß√µes pendentes
            if (pendingRowSelections === 0) {
                setTimeout(() => finishTurn(), 500);
            }
            return;
        }
        
        const play = cardsToProcess[currentCardIndex];
        console.log('processNextCard - processing card', currentCardIndex, 'player:', play.playerIndex, 'card:', play.card.number);
        
        const needsRowSelection = placeCardOnBoard(play.playerIndex, play.card);
        
        if (needsRowSelection) {
            // Jogador precisa escolher fileira - N√ÉO avan√ßar para a pr√≥xima carta
            // A pr√≥xima carta ser√° processada quando o jogador escolher
            pendingRowSelections++;
            console.log('processNextCard - waiting for row selection, pendingRowSelections:', pendingRowSelections);
        } else {
            // Carta foi colocada normalmente - avan√ßar para a pr√≥xima
            currentCardIndex++;
            setTimeout(() => processNextCard(), 600);
        }
    }
    
    // Fun√ß√£o chamada quando um jogador termina de escolher a fileira
    function onRowSelectionComplete() {
        pendingRowSelections--;
        currentCardIndex++;
        console.log('onRowSelectionComplete - pendingRowSelections:', pendingRowSelections, 'currentCardIndex:', currentCardIndex);
        
        // Continuar processando as pr√≥ximas cartas
        setTimeout(() => processNextCard(), 600);
    }
    
    // Colocar uma carta no tabuleiro
    // Retorna true se o jogador precisa escolher uma fileira (humano), false caso contr√°rio
    function placeCardOnBoard(playerIndex, card) {
        console.log('placeCardOnBoard - player:', playerIndex, 'card:', card.number);
        console.log('placeCardOnBoard - boardRows state:');
        
        // Verificar se boardRows est√° v√°lido
        if (!boardRows || boardRows.length !== ROW_COUNT) {
            console.error('placeCardOnBoard - boardRows is invalid!', boardRows);
            return false;
        }
        
        // Encontrar a fileira correta (maior carta menor que a jogada)
        let bestRow = -1;
        let bestLastCard = -1;
        
        for (let i = 0; i < ROW_COUNT; i++) {
            const row = boardRows[i];
            
            // Verificar se a fileira est√° v√°lida e tem cartas
            if (!row || row.length === 0) {
                console.warn('placeCardOnBoard - row', i, 'is empty or invalid!');
                continue;
            }
            
            const lastCard = row[row.length - 1].number;
            console.log('placeCardOnBoard - row', i, 'lastCard:', lastCard, 'card:', card.number, 'comparison:', lastCard < card.number);
            
            if (lastCard < card.number && lastCard > bestLastCard) {
                bestRow = i;
                bestLastCard = lastCard;
            }
        }
        
        console.log('placeCardOnBoard - bestRow:', bestRow, 'bestLastCard:', bestLastCard);
        
        if (bestRow === -1) {
            // Carta √© menor que todas as √∫ltimas - jogador deve escolher uma fileira
            const currentPlayer = players[playerIndex];
            
            // Se for um BOT, escolher automaticamente
            if (currentPlayer.isBot) {
                console.log('placeCardOnBoard - BOT needs to choose row:', currentPlayer.name, 'card:', card.number);
                let minPoints = Infinity;
                let minRow = 0;
                
                for (let i = 0; i < ROW_COUNT; i++) {
                    const points = boardRows[i].reduce((acc, c) => acc + c.tdb, 0);
                    console.log('placeCardOnBoard - row', i, 'has', points, 'points');
                    if (points < minPoints) {
                        minPoints = points;
                        minRow = i;
                    }
                }
                
                console.log('placeCardOnBoard - bot chose row', minRow, 'with', minPoints, 'points');
                
                // Bot pega os pontos da fileira
                players[playerIndex].score += minPoints;
                boardRows[minRow] = [card];
                
                console.log('placeCardOnBoard - updated bot score to', players[playerIndex].score);
                console.log('placeCardOnBoard - updated board row', minRow);
                
                // Broadcast para outros jogadores
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({
                        type: 'GAME_ACTION',
                        payload: {
                            action: 'CARD_PLACED',
                            rowIndex: minRow,
                            card: card,
                            playerId: currentPlayer.id,
                            isSixthCard: true,
                            points: minPoints
                        }
                    }));
                    console.log('placeCardOnBoard - sent CARD_PLACED to server');
                } else {
                    console.error('placeCardOnBoard - WebSocket not connected!');
                }
                
                updateUI();
                
                // IMPORTANTE: Para bots, retornamos false para que processNextCard continue o processamento
                console.log('placeCardOnBoard - bot finished choosing row, returning false');
                return false;
            } else {
                // Para jogadores HUMANOS, enviar mensagem para que ELES escolham
                console.log('placeCardOnBoard - human player needs to choose row, playerIndex:', playerIndex, 'myPlayerIndex:', myPlayerIndex);
                
                // Se for EU (o jogador local), mostrar a UI de escolha
                if (playerIndex === myPlayerIndex) {
                    console.log('placeCardOnBoard - I (human player) need to choose row');
                    console.log('placeCardOnBoard - setting gameState to CHOOSE_ROW');
                    pendingPlayerCard = card;
                    selectedRowIndex = null;
                    gameState = "CHOOSE_ROW";
                    setStatus("Sua carta √© menor que todas! Selecione uma fileira e clique em COMPRAR", "action");
                    startChooseRowTimer(); // Iniciar timer de 30 segundos
                    updateUI();
                    console.log('placeCardOnBoard - UI updated, waiting for player selection');
                    return true; // Precisa de sele√ß√£o manual
                } else {
                    // Se for OUTRO jogador humano, enviar mensagem para ele escolher
                    console.log('placeCardOnBoard - sending CHOOSE_ROW_REQUEST to player:', currentPlayer.id);
                    ws.send(JSON.stringify({
                        type: 'GAME_ACTION',
                        payload: {
                            action: 'CHOOSE_ROW_REQUEST',
                            playerId: currentPlayer.id,
                            card: card,
                            playerIndex: playerIndex
                        }
                    }));
                    return true; // Aguardar resposta do jogador
                }
            }
        } else {
            // Verificar se a fileira vai ficar com 6 cartas
            if (boardRows[bestRow].length >= 5) {
                // Jogador pega os pontos da fileira
                const points = boardRows[bestRow].reduce((acc, c) => acc + c.tdb, 0);
                players[playerIndex].score += points;
                boardRows[bestRow] = [card];
                
                ws.send(JSON.stringify({
                    type: 'GAME_ACTION',
                    payload: {
                        action: 'CARD_PLACED',
                        rowIndex: bestRow,
                        card: card,
                        playerId: players[playerIndex].id,
                        isSixthCard: true,
                        points: points
                    }
                }));
            } else {
                // Adicionar carta √† fileira normalmente
                boardRows[bestRow].push(card);
                
                ws.send(JSON.stringify({
                    type: 'GAME_ACTION',
                    payload: {
                        action: 'CARD_PLACED',
                        rowIndex: bestRow,
                        card: card,
                        playerId: players[playerIndex].id,
                        isSixthCard: false
                    }
                }));
            }
        }
        
        updateUI();
        return false; // Carta colocada normalmente, n√£o precisa de sele√ß√£o
    }
    
    // Finalizar o turno
    function finishTurn() {
        console.log('finishTurn - turn:', currentTurn);
        
        // Limpar cartas jogadas
        players.forEach(p => p.lastPlayed = null);
        currentTurn++;
        
        // Verificar se a m√£o acabou (todos os jogadores sem cartas)
        const handEnded = players.every(p => p.hand.length === 0);
        
        // Verificar se alguem atingiu 66 pontos
        const someoneReached66 = players.some(p => p.score >= 66);
        
        // O jogo s√≥ acaba quando a m√£o termina E alguem tem 66+ pontos
        if (handEnded && someoneReached66) {
            gameState = "END";
            const winner = players.reduce((a, b) => a.score < b.score ? a : b);
            
            // Criar ranking completo
            const ranking = [...players].sort((a, b) => a.score - b.score);
            
            // Mostrar tela de fim de jogo
            showGameOverScreen(winner, ranking);
            
            // Broadcast fim de jogo para todos
            ws.send(JSON.stringify({
                type: 'GAME_ACTION',
                payload: {
                    action: 'GAME_OVER',
                    winner: winner.name,
                    ranking: ranking.map(p => ({ name: p.name, score: p.score, isBot: p.isBot }))
                }
            }));
        } else {
            // Distribuir novas cartas se a m√£o acabou
            if (handEnded && isHost) {
                console.log('finishTurn - hand ended, distributing new cards');
                distributeNewCards();
                // N√ÉO enviar TURN_END aqui - distributeNewCards j√° envia GAME_STATE_SYNC
                // que atualiza todos os jogadores com as novas cartas
                return; // Sair da fun√ß√£o - distributeNewCards cuida de tudo
            }
            
            // Se n√£o √© host e a m√£o acabou, aguardar distribui√ß√£o do host
            if (handEnded && !isHost) {
                console.log('finishTurn - hand ended, waiting for host to distribute');
                gameState = "WAITING";
                setStatus("Aguardando distribui√ß√£o de novas cartas...", "info");
                // Iniciar timeout de seguran√ßa para recupera√ß√£o
                startWaitingRecoveryTimer();
                updateUI();
                return;
            }
            
            // Verificar se o jogador tem cartas na m√£o antes de pedir escolha
            const myHand = players[myPlayerIndex]?.hand || [];
            
            if (myHand.length > 0) {
                gameState = "SELECT";
                setStatus("Sua vez - escolha uma carta", "action");
                // Iniciar timer de jogada do jogador
                startPlayerTurnTimer();
            } else {
                // Se n√£o tem cartas, aguardar distribui√ß√£o ou fim de jogo
                gameState = "WAITING";
                setStatus("Aguardando distribui√ß√£o de novas cartas...", "info");
                // Iniciar timeout de seguran√ßa
                startWaitingRecoveryTimer();
            }
            
            // Broadcast para outros jogadores
            ws.send(JSON.stringify({
                type: 'GAME_ACTION',
                payload: {
                    action: 'TURN_END'
                }
            }));
            
            // IMPORTANTE: Fazer bots jogarem automaticamente no pr√≥ximo turno
            // Aguardar um pouco mais para garantir que o estado foi atualizado
            if (isHost) {
                setTimeout(() => triggerBotPlays(), 1000);
            }
        }
        
        updateUI();
    }
    
    // Fun√ß√£o para fazer todos os bots jogarem
    function triggerBotPlays() {
        if (!isHost) return; // Apenas o host controla os bots
        
        console.log('triggerBotPlays - checking bots, gameState:', gameState);
        
        // N√ÉO verificar gameState - bots devem jogar independentemente do estado
        // Isso permite que bots joguem mesmo quando o jogador humano est√° em WAITING
        
        let delay = 500;
        let botsToPlay = [];
        
        players.forEach((p, idx) => {
            if (p.isBot && !p.lastPlayed && p.hand && p.hand.length > 0) {
                botsToPlay.push({ player: p, index: idx });
            }
        });
        
        console.log('triggerBotPlays - bots to play:', botsToPlay.map(b => b.player.name));
        
        botsToPlay.forEach((bot, i) => {
            const playDelay = delay + (i * 600);
            console.log('triggerBotPlays - scheduling', bot.player.name, 'to play in', playDelay, 'ms');
            setTimeout(() => {
                // Verificar apenas se o bot ainda n√£o jogou e tem cartas
                if (!bot.player.lastPlayed && bot.player.hand && bot.player.hand.length > 0) {
                    console.log('triggerBotPlays - executing play for', bot.player.name);
                    makeBotPlay(bot.index);
                } else {
                    console.log('triggerBotPlays - skipping', bot.player.name, '- already played or no cards');
                }
            }, playDelay);
        });
    }
    
    // Distribuir novas cartas para jogadores que ficaram sem
    function distributeNewCards() {
        console.log('distributeNewCards - deck remaining:', deck.length);
        
        // Verificar se todos os jogadores esgotaram suas cartas
        const allEmpty = players.every(p => p.hand.length === 0);
        
        if (!allEmpty || deck.length < players.length * 10 + 4) {
            console.log('Not all players empty or not enough cards in deck');
            return;
        }
        
        console.log('Starting new round - all players had 0 cards');
        
        // Distribuir 10 cartas para cada jogador
        players.forEach(p => {
            p.hand = [];
            for (let i = 0; i < 10; i++) {
                if (deck.length > 0) {
                    p.hand.push(deck.pop());
                }
            }
            // Ordenar a mao
            p.hand.sort((a, b) => a.number - b.number);
        });
        
        // Resetar a mesa com 4 novas cartas (1 por fileira)
        boardRows = [];
        for (let i = 0; i < 4; i++) {
            if (deck.length > 0) {
                boardRows[i] = [deck.pop()];
            } else {
                boardRows[i] = [];
            }
        }
        
        console.log('New round started - cards distributed, deck remaining:', deck.length);
        
        // Enviar novo estado do jogo
        const newGameState = {
            hands: players.map(p => p.hand),
            boardRows: boardRows,
            currentTurn: currentTurn
        };
        
        ws.send(JSON.stringify({
            type: 'GAME_STATE_SYNC',
            payload: { gameState: newGameState }
        }));
        
        // Atualizar o gameState do host tamb√©m
        gameState = "SELECT";
        setStatus("Sua vez - escolha uma carta", "action");
        startPlayerTurnTimer();
        updateUI();
        
        // Fazer bots jogarem
        setTimeout(() => triggerBotPlays(), 1000);
    }

    // Fun√ß√£o para iniciar o timer de jogada do jogador
    function startPlayerTurnTimer() {
        // Limpar timer anterior se existir
        if (playerTurnTimer) {
            clearTimeout(playerTurnTimer);
        }
        
        console.log('startPlayerTurnTimer - iniciando timer de 30 segundos');
        playerTurnTimeLeft = 30;
        
        playerTurnTimer = setTimeout(() => {
            console.log('startPlayerTurnTimer - tempo esgotado, for√ßando jogada autom√°tica');
            // Tempo esgotado - for√ßar jogada autom√°tica da primeira carta
            if (gameState === "SELECT" && myPlayerIndex !== -1) {
                const player = players[myPlayerIndex];
                if (player && player.hand && player.hand.length > 0) {
                    console.log('startPlayerTurnTimer - jogando carta 0 automaticamente');
                    handleCardClick(0);
                }
            }
        }, 30000); // 30 segundos
    }
    
    // Fun√ß√£o para iniciar o timer de escolha de fileira
    function startChooseRowTimer() {
        // Limpar timer anterior se existir
        if (chooseRowTimer) {
            clearInterval(chooseRowTimer);
        }
        
        chooseRowTimeLeft = 30;
        updateTimerDisplay();
        
        chooseRowTimer = setInterval(() => {
            chooseRowTimeLeft--;
            updateTimerDisplay();
            
            if (chooseRowTimeLeft <= 0) {
                // Tempo esgotado - comprar automaticamente a fileira com menos pontos
                clearInterval(chooseRowTimer);
                chooseRowTimer = null;
                autoSelectBestRow();
            }
        }, 1000);
    }
    
    // Fun√ß√£o para atualizar o display do timer
    function updateTimerDisplay() {
        const timerEl = document.getElementById('choose-row-timer');
        if (timerEl) {
            timerEl.textContent = chooseRowTimeLeft;
            // Mudar cor quando ficar pouco tempo
            if (chooseRowTimeLeft <= 10) {
                timerEl.style.color = '#ff4444';
                timerEl.style.animation = 'pulse 0.5s infinite';
            } else {
                timerEl.style.color = '#ff6b6b';
                timerEl.style.animation = 'none';
            }
        }
    }
    
    // Fun√ß√£o para parar o timer
    function stopChooseRowTimer() {
        if (chooseRowTimer) {
            clearInterval(chooseRowTimer);
            chooseRowTimer = null;
        }
    }
    
    // Fun√ß√£o para iniciar timer de recupera√ß√£o quando em estado WAITING
    function startWaitingRecoveryTimer() {
        // Limpar timer anterior se existir
        if (waitingRecoveryTimer) {
            clearTimeout(waitingRecoveryTimer);
        }
        
        console.log('startWaitingRecoveryTimer - iniciando timer de recupera√ß√£o de 10 segundos');
        
        waitingRecoveryTimer = setTimeout(() => {
            console.log('startWaitingRecoveryTimer - timeout atingido, verificando estado');
            console.log('startWaitingRecoveryTimer - gameState:', gameState, 'myHand:', players[myPlayerIndex]?.hand?.length);
            
            // Se ainda estamos em WAITING mas temos cartas, for√ßar SELECT
            const myHand = players[myPlayerIndex]?.hand || [];
            
            if (gameState === "WAITING" && myHand.length > 0) {
                console.warn('startWaitingRecoveryTimer - RECUPERA√á√ÉO: Temos cartas mas estamos em WAITING, for√ßando SELECT');
                gameState = "SELECT";
                setStatus("Sua vez - escolha uma carta", "action");
                startPlayerTurnTimer();
                updateUI();
            } else if (gameState === "WAITING" && myHand.length === 0) {
                console.log('startWaitingRecoveryTimer - ainda sem cartas, solicitando sync do host');
                // Solicitar sincroniza√ß√£o do host
                ws.send(JSON.stringify({
                    type: 'GAME_ACTION',
                    payload: {
                        action: 'REQUEST_FULL_SYNC'
                    }
                }));
                // Reiniciar timer para tentar novamente
                startWaitingRecoveryTimer();
            }
        }, 10000); // 10 segundos
    }
    
    // Fun√ß√£o para parar timer de recupera√ß√£o
    function stopWaitingRecoveryTimer() {
        if (waitingRecoveryTimer) {
            clearTimeout(waitingRecoveryTimer);
            waitingRecoveryTimer = null;
        }
    }
    
    // Fun√ß√£o para iniciar verifica√ß√£o peri√≥dica de estado (anti-travamento)
    function startStateCheckInterval() {
        // Limpar intervalo anterior se existir
        if (stateCheckInterval) {
            clearInterval(stateCheckInterval);
        }
        
        console.log('startStateCheckInterval - iniciando verifica√ß√£o peri√≥dica a cada 5 segundos');
        
        stateCheckInterval = setInterval(() => {
            // S√≥ verificar se estamos em jogo
            if (gameState === "LOBBY" || gameState === "END") {
                return;
            }
            
            console.log('stateCheckInterval - verificando estado:', gameState);
            
            const myHand = players[myPlayerIndex]?.hand || [];
            const myPlayer = players[myPlayerIndex];
            
            // Verifica√ß√£o 1: Estamos em WAITING mas temos cartas e n√£o jogamos ainda
            if (gameState === "WAITING" && myHand.length > 0 && myPlayer && !myPlayer.lastPlayed) {
                console.warn('stateCheckInterval - ANOMALIA DETECTADA: WAITING com cartas e sem jogar');
                gameState = "SELECT";
                setStatus("Sua vez - escolha uma carta", "action");
                startPlayerTurnTimer();
                updateUI();
            }
            
            // Verifica√ß√£o 2: Todos jogaram mas ainda estamos em WAITING (apenas host processa)
            if (isHost && gameState === "WAITING") {
                const allPlayed = players.every(p => p.lastPlayed !== null);
                if (allPlayed) {
                    console.warn('stateCheckInterval - ANOMALIA DETECTADA: Todos jogaram mas ainda em WAITING');
                    console.log('stateCheckInterval - host calling checkAllPlayersPlayed instead of processRound directly');
                    checkAllPlayersPlayed();
                }
            } else if (!isHost && gameState === "WAITING") {
                // Jogador n√£o-host: apenas solicitar sync do host se todos parecem ter jogado
                const allPlayed = players.every(p => p.lastPlayed !== null);
                if (allPlayed) {
                    console.warn('stateCheckInterval - non-host: all played but still WAITING, requesting sync');
                    ws.send(JSON.stringify({
                        type: 'GAME_ACTION',
                        payload: {
                            action: 'REQUEST_SYNC'
                        }
                    }));
                }
            }
            
            // Verifica√ß√£o 3: Estamos em SELECT mas j√° jogamos
            if (gameState === "SELECT" && myPlayer && myPlayer.lastPlayed !== null) {
                console.warn('stateCheckInterval - ANOMALIA DETECTADA: SELECT mas j√° jogamos');
                gameState = "WAITING";
                setStatus("Aguardando outros jogadores...", "info");
                updateUI();
            }
        }, 5000); // A cada 5 segundos
    }
    
    // Fun√ß√£o para parar verifica√ß√£o peri√≥dica
    function stopStateCheckInterval() {
        if (stateCheckInterval) {
            clearInterval(stateCheckInterval);
            stateCheckInterval = null;
        }
    }
    
    // Fun√ß√£o para selecionar automaticamente a melhor fileira (menos pontos)
    function autoSelectBestRow() {
        console.log('autoSelectBestRow - tempo esgotado, selecionando automaticamente');
        
        if (gameState !== "CHOOSE_ROW" || !pendingPlayerCard) {
            return;
        }
        
        // Encontrar a fileira com menos pontos
        let minPoints = Infinity;
        let minRow = 0;
        
        for (let i = 0; i < ROW_COUNT; i++) {
            const points = boardRows[i].reduce((acc, c) => acc + c.tdb, 0);
            if (points < minPoints) {
                minPoints = points;
                minRow = i;
            }
        }
        
        selectedRowIndex = minRow;
        confirmRowPurchase();
    }
    
    // Fun√ß√£o para selecionar uma fileira (marca o radio button)
    function selectRow(rowIdx) {
        console.log('selectRow called - rowIdx:', rowIdx);
        
        if (gameState !== "CHOOSE_ROW") {
            console.log('selectRow - ignoring, not in CHOOSE_ROW state');
            return;
        }
        if (!pendingPlayerCard) {
            console.log('selectRow - ignoring, no pending card');
            return;
        }
        
        selectedRowIndex = rowIdx;
        console.log('selectRow - selected row:', selectedRowIndex);
        
        // Marcar o radio button correspondente
        const radio = document.getElementById('radio-row-' + rowIdx);
        if (radio) {
            radio.checked = true;
        }
        
        // Habilitar o bot√£o de comprar
        const buyBtn = document.getElementById('buy-row-btn');
        if (buyBtn) {
            buyBtn.disabled = false;
        }
        
        updateUI();
    }
    
    // Fun√ß√£o para confirmar a compra da fileira selecionada
    function confirmRowPurchase() {
        console.log('confirmRowPurchase called - selectedRowIndex:', selectedRowIndex);
        
        // Parar o timer
        stopChooseRowTimer();
        
        if (gameState !== "CHOOSE_ROW") {
            console.log('confirmRowPurchase - ignoring, not in CHOOSE_ROW state');
            return;
        }
        if (!pendingPlayerCard) {
            console.log('confirmRowPurchase - ignoring, no pending card');
            return;
        }
        if (selectedRowIndex === null) {
            showError('Selecione uma fileira primeiro!');
            return;
        }
        if (myPlayerIndex === -1) {
            console.log('confirmRowPurchase - ignoring, myPlayerIndex not set');
            return;
        }

        console.log('confirmRowPurchase - processing row selection:', selectedRowIndex);
        
        const row = boardRows[selectedRowIndex];
        const points = row.reduce((acc, c) => acc + c.tdb, 0);
        
        // Adicionar a carta a fileira e jogador pega os pontos
        players[myPlayerIndex].score += points;
        boardRows[selectedRowIndex] = [pendingPlayerCard];
        
        // Enviar para o servidor
        ws.send(JSON.stringify({
            type: 'GAME_ACTION',
            payload: {
                action: 'ROW_SELECTED',
                rowIndex: selectedRowIndex,
                card: pendingPlayerCard,
                points: points,
                playerId: playerId
            }
        }));
        
        pendingPlayerCard = null;
        selectedRowIndex = null;
        gameState = "WAITING";
        setStatus("Aguardando outros jogadores...");
        
        // Resetar radio buttons
        for (let i = 0; i < 4; i++) {
            const radio = document.getElementById('radio-row-' + i);
            if (radio) radio.checked = false;
        }
        
        updateUI();
        
        // Notificar que a sele√ß√£o foi conclu√≠da para continuar processando as cartas
        if (isHost) {
            onRowSelectionComplete();
        }
    }
    
    // Fun√ß√£o antiga handleRowClick - mantida para compatibilidade
    function handleRowClick(rowIdx) {
        selectRow(rowIdx);
    }

    // --- UI Helpers ---
    function showGameMenu() {
        const menu = document.getElementById('game-menu');
        if (menu) {
            menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
        }
    }
    
    function requestRestart() {
        if (confirm('Deseja reiniciar o jogo? Todos os jogadores precisam confirmar.')) {
            ws.send(JSON.stringify({
                type: 'GAME_ACTION',
                payload: {
                    action: 'RESTART_REQUEST'
                }
            }));
            showGameMenu();
        }
    }

    function surrenderGame() {
        if (confirm('Deseja desistir do jogo?')) {
            ws.send(JSON.stringify({
                type: 'GAME_ACTION',
                payload: {
                    action: 'SURRENDER'
                }
            }));
            setTimeout(() => exitGame(), 1000);
        }
    }
        function exitGame() {
        if (confirm("Deseja realmente sair e voltar para o menu principal?")) {
            // Fechar conex√£o WebSocket
            if (ws) ws.close();
            
            // Limpar URL (remover c√≥digo da sala) e recarregar
            window.location.href = window.location.origin + window.location.pathname;
        }
    }

    function showGameOverScreen(winner, ranking) {
        const winnerDiv = document.getElementById('end-winner');
        winnerDiv.innerHTML = `üèÜ ${winner.name}${winner.isBot ? ' ü§ñ' : ''} venceu!`;
        
        // Preencher o ranking
        const rankingDiv = document.getElementById('end-ranking');
        let rankingHTML = '<div style="text-align: center; font-weight: bold; margin-bottom: 15px; color: var(--accent-color);">Ranking Final</div>';
        ranking.forEach((p, idx) => {
            const medal = idx === 0 ? 'ü•á' : idx === 1 ? 'ü•à' : idx === 2 ? 'ü•â' : `${idx + 1}¬∫`;
            const botIcon = p.isBot ? ' ü§ñ' : '';
            rankingHTML += `<div style="display: flex; justify-content: space-between; padding: 8px; background: ${idx === 0 ? 'rgba(187, 134, 252, 0.1)' : 'transparent'}; border-radius: 4px; margin-bottom: 5px;">`;
            rankingHTML += `<span>${medal} ${p.name}${botIcon}</span>`;
            rankingHTML += `<span style="font-weight: bold;">${p.score} pts</span>`;
            rankingHTML += `</div>`;
        });
        rankingDiv.innerHTML = rankingHTML;
        
        // Mostrar o overlay
        document.getElementById('overlay').style.display = 'flex';
    }
    
    function playAgain() {
        // Recarregar a p√°gina para come√ßar um novo jogo
        location.reload();
    }

    function setStatus(msg, type = "normal") {
        const el = document.getElementById("status-bar");
        if (!el) return;
        el.textContent = msg;
        el.className = ""; 
        if (type === "action") el.classList.add("status-action");
        if (type === "error") el.classList.add("status-error");
        
        const roundEl = document.getElementById("round-num");
        if (roundEl) roundEl.textContent = currentTurn;
    }

    function createCardElement(card, isClickable = false, index = -1) {
        const el = document.createElement("div");
        el.className = "card";
        if (card.tdb < 2) el.classList.add("risk-low");
        else if (card.tdb < 5) el.classList.add("risk-med");
        else el.classList.add("risk-high");

        el.innerHTML = `<div class="card-number">${card.number}</div><div class="card-dots">${"‚óè".repeat(card.tdb)}</div>`;

        if (isClickable) el.onclick = () => handleCardClick(index);
        else if (index !== -1) el.classList.add("disabled");
        
        return el;
    }

    function updateBotsActionArea() {
        const area = document.getElementById("bots-action-area");
        if (!area) return;
        area.innerHTML = "";
        
        if (gameState === "WAITING" || gameState === "CHOOSE_ROW") {
            players.forEach(p => {
                if (p.lastPlayed) {
                    const div = document.createElement("div");
                    div.className = "bot-action-card visible";
                    div.innerHTML = `${p.name}: <strong>${p.lastPlayed.number}</strong>`;
                    if (p.id === playerId) div.style.border = "1px solid var(--accent-color)";
                    area.appendChild(div);
                }
            });
        }
    }

    function updateUI() {
        if (!document.getElementById('game-screen').classList.contains('show')) return;
        
        // Mostrar/ocultar header com timer e bot√£o de compra
        const chooseRowHeader = document.getElementById('choose-row-header');
        const buyRowContainer = document.getElementById('buy-row-container');
        const buyRowBtn = document.getElementById('buy-row-btn');
        
        const isChooseRowMode = (gameState === "CHOOSE_ROW" && pendingPlayerCard);
        
        // Adicionar/remover classe no body para aplicar estilos espec√≠ficos no mobile
        if (isChooseRowMode) {
            document.body.classList.add('choosing-row');
            if (chooseRowHeader) chooseRowHeader.style.display = 'block';
            if (buyRowContainer) buyRowContainer.style.display = 'block';
            if (buyRowBtn) buyRowBtn.disabled = selectedRowIndex === null;
        } else {
            document.body.classList.remove('choosing-row');
            if (chooseRowHeader) chooseRowHeader.style.display = 'none';
            if (buyRowContainer) buyRowContainer.style.display = 'none';
        }
        
        // Mostrar/ocultar radio buttons
        for (let i = 0; i < ROW_COUNT; i++) {
            const radio = document.getElementById(`radio-row-${i}`);
            const radioLabel = document.getElementById(`radio-label-${i}`);
            
            if (isChooseRowMode) {
                if (radio) radio.style.display = 'block';
                if (radioLabel) radioLabel.style.display = 'flex';
            } else {
                if (radio) {
                    radio.style.display = 'none';
                    radio.checked = false;
                }
                if (radioLabel) radioLabel.style.display = 'none';
            }
        }

        for (let i = 0; i < ROW_COUNT; i++) {
            const rowDiv = document.getElementById(`row-${i}`);
            if (!rowDiv) continue;
            rowDiv.innerHTML = "";
            const rowCards = boardRows[i] || [];
            const isDanger = rowCards.length === MAX_ROW_LENGTH;
            
            if (isChooseRowMode) {
                rowDiv.className = "row selectable";
                if (selectedRowIndex === i) rowDiv.classList.add("selected");
                rowDiv.onclick = () => selectRow(i);
            } else {
                rowDiv.className = "row";
                rowDiv.onclick = null;
            }
            
            if (isDanger) rowDiv.classList.add("full-danger");

            for (let j = 0; j < 6; j++) {
                if (j < rowCards.length) {
                    rowDiv.appendChild(createCardElement(rowCards[j]));
                } else if (j < 5) {
                    const emptySlot = document.createElement("div");
                    emptySlot.className = "slot empty";
                    rowDiv.appendChild(emptySlot);
                } else {
                    const sixthSlot = document.createElement("div");
                    sixthSlot.className = "slot sixth";
                    rowDiv.appendChild(sixthSlot);
                }
            }
        }

        const handDiv = document.getElementById("player-hand");
        if (handDiv && myPlayerIndex !== -1) {
            handDiv.innerHTML = "";
            const myHand = players[myPlayerIndex]?.hand || [];
            myHand.forEach((card, idx) => {
                const isMyTurn = (gameState === "SELECT");
                handDiv.appendChild(createCardElement(card, isMyTurn, idx));
            });
        }

        const sbList = document.getElementById("scoreboard-list");
        if (sbList) {
            sbList.innerHTML = "";
            let sortedPlayers = [...players].sort((a,b) => a.score - b.score);
            
            console.log('updateUI - scoreboard players:', sortedPlayers.map(p => ({ name: p.name, isBot: p.isBot, score: p.score })));
            
            sortedPlayers.forEach((p, idx) => {
                const entry = document.createElement("div");
                entry.className = "score-entry";
                if (idx === 0 && p.score < SCORE_LIMIT) entry.classList.add("leader"); 
                if (p.score >= SCORE_LIMIT) entry.classList.add("danger");
                if (p.id === playerId) entry.classList.add("human");
                
                let skull = p.score >= SCORE_LIMIT ? "üíÄ" : "";
                let botIcon = p.isBot ? " ü§ñ" : "";
                
                entry.innerHTML = `
                    <span class="score-name">${p.name}${botIcon}</span>
                    <span class="score-val">${p.score} ${skull}</span>
                `;
                sbList.appendChild(entry);
            });
        }
        
        // Atualizar placar mobile tamb√©m
        const mobileSbList = document.getElementById("mobile-scoreboard-list");
        if (mobileSbList) {
            mobileSbList.innerHTML = "";
            let sortedPlayers = [...players].sort((a,b) => a.score - b.score);
            
            sortedPlayers.forEach((p, idx) => {
                const entry = document.createElement("div");
                entry.className = "score-entry";
                if (idx === 0 && p.score < SCORE_LIMIT) entry.classList.add("leader"); 
                if (p.score >= SCORE_LIMIT) entry.classList.add("danger");
                if (p.id === playerId) entry.classList.add("human");
                
                let skull = p.score >= SCORE_LIMIT ? "üíÄ" : "";
                let botIcon = p.isBot ? " ü§ñ" : "";
                
                entry.innerHTML = `
                    <span class="score-name">${p.name}${botIcon}</span>
                    <span class="score-val">${p.score} ${skull}</span>
                `;
                mobileSbList.appendChild(entry);
            });
        }
        
        // Atualizar n√∫mero da rodada no mobile
        const mobileRoundNum = document.getElementById("mobile-round-num");
        if (mobileRoundNum) {
            mobileRoundNum.textContent = currentTurn;
        }
        
        // Atualizar placar inline mobile (abaixo da m√£o)
        const mobileInlineSbList = document.getElementById("mobile-inline-scoreboard-list");
        if (mobileInlineSbList) {
            mobileInlineSbList.innerHTML = "";
            let sortedPlayers = [...players].sort((a,b) => a.score - b.score);
            
            sortedPlayers.forEach((p, idx) => {
                const entry = document.createElement("div");
                entry.className = "score-entry";
                if (idx === 0 && p.score < SCORE_LIMIT) entry.classList.add("leader"); 
                if (p.score >= SCORE_LIMIT) entry.classList.add("danger");
                if (p.id === playerId) entry.classList.add("human");
                
                let skull = p.score >= SCORE_LIMIT ? "üíÄ" : "";
                let botIcon = p.isBot ? " ü§ñ" : "";
                
                entry.innerHTML = `
                    <span class="score-name">${p.name}${botIcon}</span>
                    <span class="score-val">${p.score} ${skull}</span>
                `;
                mobileInlineSbList.appendChild(entry);
            });
        }
        
        // Atualizar n√∫mero da rodada no placar inline mobile
        const mobileInlineRoundNum = document.getElementById("mobile-inline-round-num");
        if (mobileInlineRoundNum) {
            mobileInlineRoundNum.textContent = currentTurn;
        }
        
        updateBotsActionArea();
    }
    
    // Fun√ß√£o para alternar o placar mobile
    function toggleMobilePlacar() {
        const modal = document.getElementById('mobile-placar-modal');
        if (modal) {
            modal.classList.toggle('show');
        }
    }
    
    // Fun√ß√£o para alternar o placar no desktop (se necess√°rio)
    function togglePlacar() {
        const content = document.getElementById('scoreboard-content');
        const icon = document.getElementById('toggle-placar-icon');
        if (content && icon) {
            if (content.style.display === 'none') {
                content.style.display = 'block';
                icon.textContent = '‚ñº';
            } else {
                content.style.display = 'none';
                icon.textContent = '‚ñ∂';
            }
        }
    }

    // Check for room code in URL
    window.onload = () => {
        const urlParams = new URLSearchParams(window.location.search);
        const roomCode = urlParams.get('room');
        if (roomCode) {
            document.getElementById('room-code').value = roomCode.toUpperCase();
            showJoinForm();
        }
    };

</script>
</body>
</html>
